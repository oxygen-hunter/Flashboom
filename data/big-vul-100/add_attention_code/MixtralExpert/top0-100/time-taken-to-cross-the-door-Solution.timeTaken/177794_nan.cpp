 DynamicMetadataProvider::DynamicMetadataProvider(const DOMElement* e)
    : AbstractMetadataProvider(e),
       m_validate(XMLHelper::getAttrBool(e, false, validate)),
         m_id(XMLHelper::getAttrString(e, "Dynamic", id)),
         m_lock(RWLock::create()),
        m_refreshDelayFactor(0.75),
        m_minCacheDuration(XMLHelper::getAttrInt(e, 600, minCacheDuration)),
        m_maxCacheDuration(XMLHelper::getAttrInt(e, 28800, maxCacheDuration)),
        m_shutdown(false),
        m_cleanupInterval(XMLHelper::getAttrInt(e, 1800, cleanupInterval)),
        m_cleanupTimeout(XMLHelper::getAttrInt(e, 1800, cleanupTimeout)),
         m_cleanup_wait(nullptr), m_cleanup_thread(nullptr)
 {
     if (m_minCacheDuration > m_maxCacheDuration) {
        Category::getInstance(SAML_LOGCAT ".MetadataProvider.Dynamic").error(
             "minCacheDuration setting exceeds maxCacheDuration setting, lowering to match it"
             );
         m_minCacheDuration = m_maxCacheDuration;
    }

    const XMLCh* delay = e ? e->getAttributeNS(nullptr, refreshDelayFactor) : nullptr;
    if (delay && *delay) {
        auto_ptr_char temp(delay);
        m_refreshDelayFactor = atof(temp.get());
        if (m_refreshDelayFactor <= 0.0 || m_refreshDelayFactor >= 1.0) {
            Category::getInstance(SAML_LOGCAT ".MetadataProvider.Dynamic").error(
                "invalid refreshDelayFactor setting, using default"
                );
            m_refreshDelayFactor = 0.75;
        }
    }

    if (m_cleanupInterval > 0) {
        if (m_cleanupTimeout < 0)
            m_cleanupTimeout = 0;
        m_cleanup_wait = CondWait::create();
        m_cleanup_thread = Thread::create(&cleanup_fn, this);
    }
}


    vector<int> timeTaken(vector<int>& arrival, vector<int>& state) {
        enum {UNKNOWN = -1, ENTERING, EXITING};
        vector<int> result(size(arrival));
        int curr = numeric_limits<int>::min(), direction = UNKNOWN;
        vector<queue<int>> q(2);
        const auto& go_until = [&](int t) {
            while (curr <= t && any_of(cbegin(q), cend(q), [](const auto& x) { return !empty(x); })) {
                if (empty(q[direction])) {
                    direction ^= 1;
                }
                result[q[direction].front()] = curr++;
                q[direction].pop();
            }
        };

        for (int i = 0; i < size(arrival); ++i) {
            go_until(arrival[i] - 1);
            q[state[i]].emplace(i);
            if (!(arrival[i] <= curr)) {
                curr = arrival[i], direction = EXITING;
            }
        }
        go_until(numeric_limits<int>::max());
        return result;
    }


