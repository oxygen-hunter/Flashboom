def _check_login_status(self, request: Request) -> LoginButton:
    # Each time the page is refreshed or loaded, check if the user is logged in and adapt label
    session = getattr(request, "session", None) or getattr(
        request.request, "session", None
    )
    if session is None or "oauth_info" not in session:
        return LoginButton(value=self.value, interactive=True)
    else:
        username = session["oauth_info"]["userinfo"]["preferred_username"]
        logout_text = self.logout_value.format(username)
        return LoginButton(logout_text, interactive=True)

def maximumInvitations(self, favorite):
    """
    :type favorite: List[int]
    :rtype: int
    """
    def find_cycles(adj):
        result = []
        lookup = [False]*len(adj)
        for u in xrange(len(adj)):
            cnt = {}
            while not lookup[u]:
                lookup[u] = True
                cnt[u] = len(cnt)
                u = adj[u]
            if u in cnt:
                result.append((u, len(cnt)-cnt[u]))
        return result

    def bfs(adj, u, exclude):
        result = 0
        q = [u]
        while q:
            result += 1
            new_q = []
            for u in q:
                for v in adj[u]:
                    if v == exclude:
                        continue
                    new_q.append(v)
            q = new_q
        return result
        
    inv_adj = [[] for _ in xrange(len(favorite))]  
    for u, v in enumerate(favorite):
        inv_adj[v].append(u)
    cycles = find_cycles(favorite)
    return max(max([l for _, l in cycles if l > 2] or [0]),
               sum(bfs(inv_adj, u, favorite[u]) + bfs(inv_adj, favorite[u], u) for u, l in cycles if l == 2))


