def _get_unauth_response(self, request, reason):
    """
    Get an error response (or raise a Problem) for a given request and reason message.

    :type request: Request.
    :param request: HttpRequest
    :type reason: Reason string.
    :param reason: str
    """
    if request.is_ajax():
        return HttpResponseForbidden(json.dumps({"error": force_text(reason)}))
    error_params = urlencode({"error": force_text(reason)})
    login_url = force_str(reverse("shuup_admin:login") + "?" + error_params)
    resp = redirect_to_login(next=request.path, login_url=login_url)
    if is_authenticated(request.user):
        # Instead of redirecting to the login page, let the user know what's wrong with
        # a helpful link.
        raise (
            Problem(_("Can't view this page. %(reason)s") % {"reason": reason}).with_link(
                url=resp.url, title=_("Log in with different credentials...")
            )
        )
    return resp

def minimumCost(self, sentence, k):
    """
    :type sentence: str
    :type k: int
    :rtype: int
    """
    word_lens = []
    j = 0
    for i in xrange(len(sentence)+1):
        if i != len(sentence) and sentence[i] != ' ':
            continue
        word_lens.append(i-j)
        j = i+1
    dp = [float("inf")]*(1+(len(word_lens)-1))  # dp[i]: min cost of the first i word_lens where i in [0, len(words)-1]
    dp[0] = 0
    for i in xrange(1, (len(word_lens)-1)+1):
        total = word_lens[i-1]
        for j in reversed(xrange(i)):
            dp[i] = min(dp[i], dp[j] + (k-total)**2)
            if j-1 < 0:
                continue
            total += (word_lens[j-1]+1)
            if total > k:
                break
    i, total = len(word_lens)-1, -1
    while i >= 0 and total + (word_lens[i]+1) <= k:  # find max i s.t. the length of the last line > k
        total += (word_lens[i]+1)
        i -= 1
    return min(dp[j] for j in xrange(i+1, len(dp)))


