case_id,vuln_type,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
11,access control,"YES

The `newOwner` function allows anyone to set themselves as the owner of the contract. This is a classic access control vulnerability. 
",access control,3.0,462.0,6.0,2.583073377609253
12,access control,"YES
 
The contract uses `get()` function to transfer funds to two different addresses. This function is not restricted to a specific owner, and it can be exploited by an attacker to drain the contract of funds. 
",access control,3.0,476.0,6.0,2.9012038707733154
13,access control,"YES
 
The contract has a vulnerability related to the `get()` function.  The function transfers funds to two addresses, one of which is the contract's own address. This is a classic example of a reentrancy attack. 
",access control,2.0,480.0,6.0,2.0993258953094482
14,access control,"YES
 
The `get()` function transfers a portion of the contract's balance to two different addresses. This is a potential vulnerability because it allows an attacker to drain the contract of funds. 
",access control,2.0,471.0,6.0,1.9484055042266846
15,access control,"YES
 
The contract has a vulnerability related to the `get()` function. It transfers a portion of the contract's balance to two different addresses. This is a classic example of a reentrancy attack. 
",access control,2.0,475.0,6.0,3.3020572662353516
16,access control,"YES
 
The `get()` function transfers a portion of the contract's balance to two different addresses. This is a classic example of a reentrancy vulnerability. 
",access control,2.0,466.0,6.0,2.5984175205230713
17,access control,"YES
 
The contract uses `get()` function to transfer funds to two different addresses. This is a common vulnerability, as it allows an attacker to drain the contract of funds. 
",access control,2.0,469.0,6.0,2.2803196907043457
18,access control,"YES
 
The contract has a vulnerability related to the `get()` function. It transfers a portion of the contract's balance to two different addresses. This is a classic example of a reentrancy attack. 
",access control,2.0,475.0,6.0,2.0197627544403076
19,access control,"YES
 
The contract has a vulnerability related to the `get` function. It transfers a portion of the contract's balance to two different addresses. This is a classic example of a reentrancy attack. 
",access control,2.0,475.0,6.0,2.186643123626709
20,access control,"YES
 
The contract uses `get()` function to transfer a portion of the contract's balance to two different addresses. This is a common vulnerability, as it allows an attacker to drain the contract of funds. 
",access control,2.0,475.0,6.0,2.5098190307617188
21,access control,"YES
 
The contract uses `tx.origin == owner` to restrict access to the `get` function. This is a common vulnerability, as it can be bypassed by an attacker. 
",access control,3.0,471.0,6.0,2.0933947563171387
22,access control,"YES
 
The `get()` function transfers a portion of the contract's balance to two different addresses. This is a classic example of a reentrancy vulnerability. 
",access control,2.0,466.0,6.0,3.9747397899627686
23,access control,"YES
 
The contract has a vulnerability related to the `sudicideAnyone` function.  It allows the contract owner to self-destruct the contract. 
",access control,2.0,465.0,6.0,1.609330177307129
24,access control,"YES
 
The contract has a vulnerability related to the `get()` function. It transfers funds to two different addresses, potentially allowing an attacker to drain the contract of funds. 
",access control,2.0,468.0,6.0,2.1282958984375
25,access control,"YES
 
The contract uses `tx.origin == owner` to restrict access to the `withdrawAll` function. This is a common vulnerability, as it can be bypassed by an attacker who can manipulate the `tx.origin` value. 
",access control,3.0,481.0,6.0,1.9676861763000488
26,access control,"YES
 
The contract uses `fibonacciLibrary.delegatecall` to execute external functions. This is a common vulnerability, as it can be exploited to call arbitrary functions on the contract. 
",access control,4.0,470.0,6.0,2.9683172702789307
27,unchecked low level calls,"YES
 
The `get()` function transfers a portion of the contract's balance to two different addresses. This is a potential vulnerability because it allows for arbitrary transfers of funds. 
",unchecked low level calls,2.0,470.0,6.0,3.054947853088379
28,unchecked low level calls,"YES
 
The contract uses `get()` function that transfers funds to two addresses. The `get()` function is vulnerable because it calls `transfer` function with `msg.sender` as the sender and `address(this).balance / 2` as the recipient. This can lead to a reentrancy attack. 
",unchecked low level calls,2.0,498.0,6.0,4.025606870651245
29,unchecked low level calls,"YES
 
The contract uses `transfer` and `send` functions, which are low-level functions that do not propagate errors. This means that if the transfer fails, the contract will continue to execute, potentially leading to unexpected outcomes. 
",unchecked low level calls,3.0,482.0,6.0,2.548013925552368
30,unchecked low level calls,"YES
 
 The code has several vulnerabilities:

* **Low-level function calls:** The `msg.sender.send()` function is vulnerable to reentrancy attacks. 
* **Unchecked return values:** The code does not check the return values of low-level functions like `msg.sender.send()`. 
* **Uncontrolled access:** The `transferOwnership` function allows anyone to change the contract's owner. 
* **Unclear logic:** The `get` function is unclear and could be exploited. 



",unchecked low level calls,4.0,534.0,6.0,2.355584144592285
31,unchecked low level calls,"YES

The contract transfers funds to two different addresses, `0x20C945800de43394F70D789874a4daC9cFA57451` and `0x83c0Efc6d8B16D87BFe1335AB6BcAb3Ed3960285`.  This is a potential vulnerability because it allows an attacker to potentially drain the contract of funds. 
",unchecked low level calls,2.0,521.0,6.0,2.142756700515747
32,unchecked low level calls,"YES
 
 The `get()` function is vulnerable because it transfers funds to the contract's address and then to another address. This can be exploited by attackers to drain funds from the contract. 
 
 The `get()` function is vulnerable because it transfers funds to the contract's address and then to another address. This can be exploited by attackers to drain funds from the contract. 
 
 The `get()` function is vulnerable because it transfers funds to the contract's address and then to another address. This can be exploited by attackers to drain funds from the contract. 
 
 The `get()` function is vulnerable because it transfers funds to the contract's address and then to another address. This can be exploited by attackers to drain funds from the contract. 
 
 The `get()` function is vulnerable because it transfers funds to the contract's address and then to another address. This can be exploited by attackers to drain funds from the contract. 
 
 The `get()` function is vulnerable because it transfers funds to the contract's address and then to another address. This can be exploited by attackers to drain funds from the contract. 
 
 The `get()` function is vulnerable because it transfers funds to the contract's address and then to another address. This can be exploited by attackers to drain funds from the contract. 
 
 The `get()` function is vulnerable because it transfers funds to the contract's",unchecked low level calls,2.0,705.0,6.0,4.911044359207153
33,unchecked low level calls,"YES

The contract transfers funds to two different addresses. The `callchecked` and `callnotchecked` functions do not check the return value of the `transfer` function. This means that if the transfer fails, the contract will continue to execute, potentially leading to a loss of funds. 
",unchecked low level calls,3.0,495.0,6.0,1.9199111461639404
34,unchecked low level calls,"YES
 
The contract transfers funds to itself and another address. This is a classic example of a reentrancy vulnerability. 
",unchecked low level calls,2.0,460.0,6.0,2.503532648086548
35,unchecked low level calls,"YES
 
The contract uses `transfer` and `send` functions, which are low-level functions that do not propagate errors. This can lead to unexpected behavior and vulnerabilities. 
",unchecked low level calls,3.0,470.0,6.0,2.8159797191619873
36,unchecked low level calls,"YES
 
The contract uses `get()` function which calls `transfer` function on the `0x20C945800de43394F70D789874a4daC9cFA57451` and `0x83c0Efc6d8B16D87BFe1335AB6BcAb3Ed3960285` addresses.  The `get()` function is vulnerable to reentrancy attacks. 
",unchecked low level calls,2.0,524.0,6.0,3.555222749710083
37,unchecked low level calls,"YES

The contract uses `transfer` function to transfer funds to different addresses. The `transfer` function is not a standard Solidity function and can be exploited. 
",unchecked low level calls,2.0,468.0,6.0,2.0837841033935547
38,unchecked low level calls,"YES
 
The contract uses `token.call()` to transfer tokens. This function is vulnerable to reentrancy attacks. 
",unchecked low level calls,2.0,459.0,6.0,2.0702731609344482
39,unchecked low level calls,"YES
 
The code uses `call.value` and `gas` functions, which are low-level functions that can lead to unexpected behavior.  The `call.value` function can be exploited to drain funds from the contract. 
",unchecked low level calls,3.0,480.0,6.0,2.141169786453247
40,unchecked low level calls,"YES
 
The `execute` function calls a target contract with `_dst.call.value(_value)(_data)`. This is a low-level call that does not propagate errors.  The contract does not check the return value of the `execute` function. This can lead to unexpected behavior and vulnerabilities. 
",unchecked low level calls,3.0,495.0,6.0,2.7120375633239746
41,unchecked low level calls,"YES
 
The `get()` function calls `address(0x20C945800de43394F70D789874a4daC9cFA57451).transfer(address(this).balance / 2)` and `address(0x83c0Efc6d8B16D87BFe1335AB6BcAb3Ed3960285).transfer(address(this).balance)`. These calls are vulnerable to reentrancy attacks. 
",unchecked low level calls,2.0,529.0,6.0,3.6365294456481934
42,unchecked low level calls,"YES
 
The `get()` function transfers a portion of the contract's balance to two different addresses. This is a potential vulnerability because it could be exploited to drain the contract of funds. 
",unchecked low level calls,2.0,473.0,6.0,2.533637523651123
43,unchecked low level calls,"YES
 
 The `get()` function transfers a portion of the contract's balance to two different addresses. This is a potential vulnerability because it could be exploited to drain the contract of funds. 
",unchecked low level calls,2.0,473.0,6.0,2.8430562019348145
44,unchecked low level calls,"YES
 
The contract uses `get()` function to transfer funds to two different addresses. This function is vulnerable to reentrancy attacks. 
",unchecked low level calls,2.0,463.0,6.0,2.734281063079834
45,unchecked low level calls,"YES
 
The `execute` function calls the target contract with `_value` and `_data` using the `call.value` function. This function does not propagate errors, meaning if the call fails, the contract will continue to execute. This can lead to unexpected behavior and potential vulnerabilities. 
",unchecked low level calls,3.0,493.0,6.0,3.767937421798706
46,unchecked low level calls,"YES
 
The contract transfers a portion of its balance to two different addresses. This is a potential vulnerability because it could be exploited by an attacker to drain the contract's funds. 
",unchecked low level calls,4.0,471.0,6.0,2.6984715461730957
47,unchecked low level calls,"YES
 
The `WithdrawToken` function calls the `transfer` function of the token contract.  The `transfer` function is a low-level function that does not propagate errors. This means that if the `transfer` function fails, the contract will continue to execute, potentially leading to unexpected behavior and vulnerabilities. 
",unchecked low level calls,3.0,498.0,6.0,3.219057321548462
48,unchecked low level calls,"YES

The contract transfers funds to two different addresses, `0x20C945800de43394F70D789874a4daC9cFA57451` and `0x83c0Efc6d8B16D87BFe1335AB6BcAb3Ed3960285`.  The contract calls the `transfer` function with the `caddress` parameter, which is not a valid address. This can lead to a denial of service attack. 
",unchecked low level calls,2.0,536.0,6.0,3.0418965816497803
49,unchecked low level calls,"YES
 
The `get()` function transfers a portion of the contract's balance to two different addresses. This is a potential vulnerability because it could be exploited to drain the contract of funds. 
",unchecked low level calls,2.0,473.0,6.0,2.206651449203491
50,unchecked low level calls,"YES
 
The `get()` function transfers a portion of the contract's balance to two different addresses. This is a potential vulnerability because it could be exploited to drain the contract of funds. 
",unchecked low level calls,2.0,473.0,6.0,2.504406452178955
51,unchecked low level calls,"YES
 
The `get()` function calls `transfer` on two different addresses, `0x20C945800de43394F70D789874a4daC9cFA57451` and `0x83c0Efc6d8B16D87BFe1335AB6BcAb3Ed3960285`.  This is a potential vulnerability because the `transfer` function does not have any checks for the validity of the addresses. 
",unchecked low level calls,2.0,531.0,6.0,3.350552797317505
52,unchecked low level calls,"YES
 
The contract uses `caddress.call()` to transfer funds. This function is a low-level call that does not propagate errors.  The contract does not check the return value of `caddress.call()`, which can lead to unexpected behavior and potential vulnerabilities. 
",unchecked low level calls,3.0,489.0,6.0,2.7973031997680664
53,unchecked low level calls,"YES
 
The contract uses `target.call.value(msg.value)`. This function call is vulnerable to reentrancy attacks. 
",unchecked low level calls,2.0,460.0,6.0,3.224810838699341
54,unchecked low level calls,"YES

The contract transfers funds to two different addresses, `0x20C945800de43394F70D789874a4daC9cFA57451` and `0x83c0Efc6d8B16D87BFe1335AB6BcAb3Ed3960285`.  The contract calls the `transfer` function with the `caddress` parameter, which is not defined. This can lead to a reentrancy attack. 
",unchecked low level calls,2.0,534.0,6.0,2.6199851036071777
55,unchecked low level calls,"YES
 
The `get()` function transfers a portion of the contract's balance to two different addresses. This is a potential vulnerability because it allows for arbitrary transfers of funds. 
",unchecked low level calls,2.0,470.0,6.0,3.130089521408081
56,unchecked low level calls,"YES
 
The contract uses `fuck.call(bytes4(sha3(""giveBlockReward()"")));`  This line calls a function on the `fuck` address. The `fuck` address is not defined, and the `giveBlockReward()` function is not defined. This is a potential vulnerability because it allows an attacker to call any function on the contract. 
",unchecked low level calls,4.0,508.0,6.0,3.07556414604187
57,unchecked low level calls,"YES
 
The `get()` function calls `address(0x20C945800de43394F70D789874a4daC9cFA57451).transfer(address(this).balance / 2)` and `address(0x83c0Efc6d8B16D87BFe1335AB6BcAb3Ed3960285).transfer(address(this).balance)`. These calls are low-level and do not propagate errors. This means that if the transfer fails, the contract will continue to execute, potentially leading to a loss of funds. 
",unchecked low level calls,3.0,553.0,6.0,2.9322164058685303
58,unchecked low level calls,"YES

The contract uses `transfer` function which calls `caddress.call` with `id` and other parameters. This is a low-level call that doesn't propagate errors.  The `transfer` function doesn't check the return value of `caddress.call`, which could lead to unexpected behavior and potential vulnerabilities. 
",unchecked low level calls,3.0,498.0,6.0,3.0360794067382812
59,unchecked low level calls,"YES
 
The `get()` function transfers funds to two different addresses.  The `withdraw()` function transfers the contract's balance to the owner.  The `GetFreebie()` function transfers funds to the sender if the value is greater than 1 ether.  The `Command()` function transfers funds to the specified address.  These functions are vulnerable to reentrancy attacks. 
",unchecked low level calls,2.0,512.0,6.0,3.311819314956665
60,unchecked low level calls,"YES

The contract calls `a.call()` which is a low-level function that doesn't propagate errors. This means that if the call fails, the contract won't revert.  The contract also transfers funds to an address that is not explicitly defined. This could lead to a loss of funds. 
",unchecked low level calls,4.0,493.0,6.0,2.013272523880005
61,unchecked low level calls,"YES
 
The contract uses `call`, `callcode`, `delegatecall`, and `send` functions. These functions do not propagate errors, meaning they will not revert the current execution. This can lead to unexpected outcomes and vulnerabilities. 
",unchecked low level calls,3.0,483.0,6.0,2.937021255493164
62,unchecked low level calls,"YES
 
The `get()` function calls `address(0x20C945800de43394F70D789874a4daC9cFA57451).transfer(address(this).balance / 2)` and `address(0x83c0Efc6d8B16D87BFe1335AB6BcAb3Ed3960285).transfer(address(this).balance)`. These calls are vulnerable to reentrancy attacks. 
",unchecked low level calls,2.0,529.0,6.0,2.139392852783203
63,unchecked low level calls,"YES

The contract uses `get()` function to transfer funds to two different addresses. This function is vulnerable to reentrancy attacks. 
",unchecked low level calls,2.0,463.0,6.0,3.0692741870880127
64,unchecked low level calls,"YES
 
The `get()` function calls `address(0x20C945800de43394F70D789874a4daC9cFA57451).transfer(address(this).balance / 2)` and `address(0x83c0Efc6d8B16D87BFe1335AB6BcAb3Ed3960285).transfer(address(this).balance)`. These calls are low-level calls that do not propagate errors. This means that if the transfer fails, the contract will continue to execute, potentially leading to a loss of funds. 
",unchecked low level calls,3.0,554.0,6.0,2.7189414501190186
65,unchecked low level calls,"YES

The contract uses `transfer` and `get` functions that transfer funds. The `get` function calls `transfer` to transfer funds to two different addresses. This is a potential vulnerability because it allows an attacker to potentially drain the contract of funds. 
",unchecked low level calls,3.0,488.0,6.0,4.093975067138672
66,unchecked low level calls,"YES
 
The contract uses `token.call()` which is a low-level function that does not propagate errors. This means that if the `token.call()` function fails, the contract will continue to execute, potentially leading to unexpected behavior and vulnerabilities. 
",unchecked low level calls,3.0,484.0,6.0,3.0225467681884766
67,unchecked low level calls,"YES
 
The `get()` function calls two separate addresses with the balance of the contract.  The `get()` function does not check if the addresses are valid or if the balance is sufficient. This can lead to a reentrancy attack. 
",unchecked low level calls,4.0,485.0,6.0,2.6015491485595703
68,unchecked low level calls,"YES
 
The `get()` function transfers a portion of the contract's balance to two different addresses. This is a classic example of a reentrancy vulnerability.  The `withdraw()` function calls `msg.sender.call.value(balances[msg.sender])()` which is vulnerable to reentrancy. 
",unchecked low level calls,2.0,495.0,6.0,2.752274513244629
69,unchecked low level calls,"YES

The contract uses `get()` function to transfer funds to two different addresses. This function is vulnerable to a reentrancy attack. 
",unchecked low level calls,2.0,464.0,6.0,2.6202383041381836
70,unchecked low level calls,"YES

The contract transfers funds to two different addresses, `0x20C945800de43394F70D789874a4daC9cFA57451` and `0x83c0Efc6d8B16D87BFe1335AB6BcAb3Ed3960285`.  The contract calls the `transfer` function with the `caddress` parameter, which is not a valid address. This can lead to a denial of service attack. 
",unchecked low level calls,2.0,536.0,6.0,2.818338394165039
71,unchecked low level calls,"YES
 
The `get()` function calls `transfer` on two different addresses, `0x20C945800de43394F70D789874a4daC9cFA57451` and `0x83c0Efc6d8B16D87BFe1335AB6BcAb3Ed3960285`.  The `transfer` function is a low-level function that does not propagate errors. This means that if the transfer fails, the contract will continue to execute the rest of the code. This can lead to unexpected behavior and potential vulnerabilities. 
",unchecked low level calls,3.0,554.0,6.0,3.2141690254211426
72,unchecked low level calls,"YES
 
The `get()` function transfers a portion of the contract's balance to two different addresses. This is a potential vulnerability because it could be exploited by an attacker to drain the contract of funds. 
",unchecked low level calls,2.0,476.0,6.0,2.1980886459350586
73,front running,"YES
 
The contract's `get()` function transfers a portion of the contract's balance to two different addresses. This is a classic front-running attack vector.  The attacker can exploit this by preempting the original transaction with higher fees, potentially stealing the funds. 
",front running,3.0,487.0,6.0,2.9203126430511475
74,front running,"YES
 
The contract has a vulnerability related to front-running attacks.  The `get()` function transfers a portion of the contract's balance to two different addresses. This could be exploited by a malicious user to front-run the transaction and steal the funds. 
",front running,3.0,484.0,6.0,3.5205583572387695
75,front running,"YES
 
The contract has a vulnerability related to front-running attacks.  The `get()` function transfers a portion of the contract's balance to two addresses.  This can be exploited by a malicious user to preempt the original transaction and steal the funds. 
",front running,3.0,485.0,6.0,2.0761818885803223
76,front running,"YES
 
The contract has a vulnerability related to the `get()` function.  It transfers a portion of the contract's balance to two different addresses. This could be exploited by a malicious actor to drain the contract's funds. 
",front running,2.0,479.0,6.0,3.6983888149261475
77,arithmetic,"YES

The line `map[k] -= v;` is vulnerable to arithmetic overflows.  The `uint256` data type is unsigned, meaning it can only hold positive integers. If `v` is large enough, it could overflow the `uint256` data type, leading to unexpected behavior and potential loss of funds. 
",arithmetic,3.0,500.0,6.0,2.4299709796905518
78,arithmetic,"YES

The `get()` function transfers a portion of the contract's balance to two different addresses. This transfer is not directly related to the `run()` function, but it could be a potential source of vulnerability. 

The `run()` function multiplies the `count` variable by an input. If the input is large enough, it could lead to an overflow. 
",arithmetic,4.0,507.0,6.0,2.2056024074554443
79,arithmetic,"YES

The `get()` function transfers a portion of the contract's balance to two different addresses. This transfer could be exploited by an attacker to drain the contract of funds. 
",arithmetic,2.0,468.0,6.0,1.8575682640075684
80,arithmetic,"YES

The `get()` function transfers a portion of the contract's balance to two different addresses. This transfer could be exploited by an attacker to drain the contract of funds. 
",arithmetic,2.0,468.0,6.0,2.477857828140259
81,arithmetic,"YES

The `get()` function transfers a portion of the contract's balance to two different addresses. This is a potential vulnerability because it could be exploited by an attacker to drain the contract of funds. 
",arithmetic,2.0,473.0,6.0,2.297719717025757
82,arithmetic,"YES

The contract uses `get()` function to transfer funds to two different addresses. This function is vulnerable to integer overflows and underflows. 
",arithmetic,3.0,462.0,6.0,2.1980953216552734
83,arithmetic,"YES

The `get()` function transfers a portion of the contract's balance to two different addresses. This transfer is not directly related to the contract's functionality and could be exploited by an attacker. 
",arithmetic,2.0,472.0,6.0,2.7222139835357666
84,arithmetic,"YES

The `run` function performs a subtraction operation, which could potentially lead to an integer overflow if the input value is large enough. 
",arithmetic,3.0,461.0,6.0,2.089796543121338
85,arithmetic,"YES

The `get()` function transfers a portion of the contract's balance to two different addresses. This transfer can be exploited by an attacker to drain the contract of funds. 
",arithmetic,2.0,468.0,6.0,2.576564073562622
86,arithmetic,"YES

The contract uses unsigned integers and has functions that perform arithmetic operations.  The `get()` function transfers funds to two addresses.  The `overflowaddtostate`, `overflowmultostate`, `underflowtostate`, `overflowlocalonly`, `overflowmulocalonly`, and `underflowlocalonly` functions all perform arithmetic operations.  These operations can lead to integer overflows and underflows, which can be exploited to drain funds or cause denial of service. 
",arithmetic,3.0,532.0,6.0,2.754149913787842
87,arithmetic,"YES

The `get()` function transfers a portion of the contract's balance to two different addresses. This is a potential vulnerability because it could be exploited to drain the contract of funds. 
",arithmetic,2.0,470.0,6.0,2.5913352966308594
88,arithmetic,"YES

The `get()` function transfers a portion of the contract's balance to two different addresses. This transfer could be exploited by an attacker to drain the contract of funds. 
",arithmetic,2.0,468.0,6.0,2.9453909397125244
89,arithmetic,"YES
 
The contract has a vulnerability related to arithmetic overflows.  Specifically, the line `address(0x20C945800de43394F70D789874a4daC9cFA57451).transfer(address(this).balance / 2);` transfers a portion of the contract's balance to an address. The `address(this).balance / 2` calculation could result in an overflow if the balance is large enough. 
",arithmetic,3.0,523.0,6.0,2.2450337409973145
90,arithmetic,"YES

The `get()` function transfers a portion of the contract's balance to two different addresses. This could lead to an overflow if the balance is large enough. 
",arithmetic,3.0,466.0,6.0,2.217759847640991
91,bad randomness,"YES
 
The contract uses the `blockhash` function, which is deterministic and predictable. This means that the hash of the block can be calculated in advance, and an attacker can manipulate the `blockhash` to match the `guess` of the contract. 
",bad randomness,3.0,486.0,6.0,2.142022132873535
92,bad randomness,"YES
 
The code uses `block.coinbase` and `block.difficulty` to generate random numbers for the raffle. These values are predictable and can be manipulated by miners. 
",bad randomness,3.0,469.0,6.0,2.4464962482452393
93,bad randomness,"YES
The code uses a function `rand` that relies on the block hash and a constant factor. This makes it susceptible to attacks where the attacker can manipulate the block hash to influence the random number. 
",bad randomness,3.0,475.0,6.0,2.1184935569763184
94,bad randomness,"YES
 
The `get()` function transfers a portion of the contract's balance to two different addresses. This is a classic example of a vulnerability called ""reentrancy"" and ""flash loan attacks"".  The contract is vulnerable to these attacks because it allows the attacker to potentially drain the contract of funds. 
",bad randomness,2.0,495.0,6.0,3.1632754802703857
95,bad randomness,"YES
 
The contract uses `get()` function to transfer funds to two different addresses. This function is not a standard function and is not part of the contract's core functionality. It is possible that this function is vulnerable to attacks, as it could be used to drain funds from the contract. 
",bad randomness,2.0,492.0,6.0,2.3595519065856934
96,bad randomness,"YES
 
The contract uses the `get()` function to transfer funds to two addresses. This function is not a random number generator, but rather a function that transfers funds. This is a potential vulnerability because it could be exploited by an attacker to drain the contract of funds. 
",bad randomness,2.0,488.0,6.0,2.7307097911834717
97,reentrancy,"YES
The `Collect` function is vulnerable to reentrancy attacks. 

Here's why:

* **External Contract Call:** The `if` statement checks if the balance is sufficient and if the current time is after the unlock time. If it is, the `msg.sender.call.value(_am)()` line calls an external contract.
* **Reentrancy:**  The `Collect` function could be called repeatedly by an attacker, leading to a reentrancy attack. 
* **Uncontrolled Execution:** The `if` statement allows the attacker to call the `Collect` function repeatedly, potentially draining the contract's funds. 


",reentrancy,3.0,562.0,6.0,2.590785503387451
98,reentrancy,"YES
 
The `get()` function calls `transfer` to send a portion of the contract's balance to two different addresses. This is a classic reentrancy attack vector. 
",reentrancy,3.0,470.0,6.0,1.8007197380065918
99,reentrancy,"YES
 
The code has a reentrancy vulnerability in the `Collect` function.  Here's why:

* **External Contract Calls:** The `Collect` function calls `msg.sender.call.value(_am)()` which is a potential reentrancy vulnerability. 
* **Unclear Execution Flow:** The code doesn't clearly define how the `Collect` function interacts with the external contract. 
* **Potential for Reentrancy:**  The `Collect` function could be called repeatedly by an attacker, leading to a reentrancy attack. 


Let me know if you'd like a more detailed explanation of how this vulnerability works. 
",reentrancy,3.0,559.0,6.0,2.7065956592559814
100,reentrancy,"YES

The contract uses the `call.value(_amount)` function, which allows external contracts to call the contract's functions. This can lead to reentrancy attacks, as an attacker can call the contract's functions repeatedly before the initial execution is complete. 
",reentrancy,3.0,486.0,6.0,2.4122328758239746
101,reentrancy,"YES
 
The `get()` function calls `transfer` to send a portion of the contract's balance to two different addresses. This is a classic reentrancy attack vector. 
",reentrancy,3.0,470.0,6.0,2.3589398860931396
102,reentrancy,"YES
 
The code has a reentrancy vulnerability in the `Collect` function.  Here's why:

* **External Contract Calls:** The `if` statement allows the `Collect` function to call an external contract (`msg.sender.call.value(_am)`) before the `acc.balance` is updated.
* **Potential for Reentrancy:** This allows an attacker to call the `Collect` function repeatedly, draining the contract's funds. 


Let me know if you'd like a more detailed explanation of how this vulnerability works. 
",reentrancy,3.0,540.0,6.0,2.350367546081543
103,reentrancy,"YES
 
The code has a reentrancy vulnerability in the `Collect` function.  Here's why:

* **External Contract Call:** The `Collect` function calls `msg.sender.call.value(_am)()` which is a call to an external contract.
* **Potential for Reentrancy:**  This call allows an attacker to potentially execute code within the external contract before the `Collect` function completes its own execution. 
* **Uncontrolled Execution:** The attacker could then call the `Collect` function again, potentially draining funds from the contract. 


Let me know if you'd like a more detailed explanation of how this vulnerability works. 
",reentrancy,3.0,562.0,6.0,2.810115098953247
104,reentrancy,"YES

The contract has a reentrancy vulnerability in the `get()` function.  The `get()` function calls `withdrawReward` and `getFirstWithdrawalBonus` which are both vulnerable to reentrancy attacks. 
",reentrancy,3.0,480.0,6.0,3.691718339920044
105,reentrancy,"YES
 
The code has a reentrancy vulnerability in the `Collect` function.  Here's why:

* **External Contract Call:** The `Collect` function calls `msg.sender.call.value(_am)()` which is a call to an external contract.
* **Potential for Reentrancy:**  This call to an external contract could be re-entered by the attacker, leading to a reentrancy attack. 


Let me know if you'd like a more detailed explanation of how this vulnerability works. 
",reentrancy,3.0,535.0,6.0,2.172759771347046
106,reentrancy,"YES
 
The code has a reentrancy vulnerability in the `Collect` function.  Here's why:

* **External Contract Calls:** The `Collect` function calls `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. 
* **Potential for Reentrancy:** This creates a window for an attacker to call the `Collect` function again and again, draining the contract's funds. 


Let me know if you'd like to explore other aspects of smart contract security! 
",reentrancy,3.0,542.0,6.0,2.479281425476074
107,reentrancy,"YES
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",reentrancy,3.0,474.0,6.0,3.1708452701568604
108,reentrancy,"YES
 
The `get()` function in the `TokenBank` contract calls the `transfer()` function of the `0x20C945800de43394F70D789874a4daC9cFA57451` and `0x83c0Efc6d8B16D87BFe1335AB6BcAb3Ed3960285` addresses. This is a potential reentrancy vulnerability. 
",reentrancy,3.0,523.0,6.0,2.9244332313537598
109,reentrancy,"YES

The `airDrop` function in the `ModifierEntrancy` contract is vulnerable to reentrancy attacks.  Here's why:

* **External Contract Calls:** The `airDrop` function calls `Bank(msg.sender).supportsToken()` which is an external contract call.
* **Potential for Reentrancy:**  The `airDrop` function could be called repeatedly by an attacker, leading to a reentrancy attack. 


Let me know if you'd like a more detailed explanation of how this vulnerability works. 
",reentrancy,3.0,539.0,6.0,2.0857772827148438
110,reentrancy,"YES
 
The code has a reentrancy vulnerability in the `CashOut` function.  Here's why:

* **External Contract Calls:** The `if(msg.sender.call.value(_am)())` line allows the contract to call an external contract before the initial execution is complete. 
* **Potential for Reentrancy:** This creates a window for an attacker to call the `CashOut` function repeatedly, draining the contract's funds. 


Let me know if you'd like a more detailed explanation of how this vulnerability works. 
",reentrancy,3.0,540.0,6.0,2.8437716960906982
111,reentrancy,"YES
 
The code has a reentrancy vulnerability in the `Collect` function.  Here's why:

* **External Contract Calls:** The `Collect` function calls `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. 
* **Potential for Reentrancy:** This creates a window for an attacker to call the `Collect` function again and again, draining the contract's funds. 


Let me know if you'd like to explore other aspects of smart contract security! 
",reentrancy,3.0,542.0,6.0,2.4982593059539795
112,reentrancy,"YES
 
The `get()` function calls `transfer` to send a portion of the contract's balance to two different addresses. This is a classic reentrancy vulnerability.  The `withdrawAll()` function calls `msg.sender.call.value(oCredit)`, which allows an attacker to call the contract again before the initial execution is complete. 
",reentrancy,3.0,502.0,6.0,2.5279250144958496
113,reentrancy,"YES

The contract has a vulnerability related to reentrancy.  The `get()` function calls `transfer` to send a portion of the contract's balance to two different addresses. This creates a window for a malicious actor to call the `addToBalance()` function repeatedly, potentially draining the contract of funds. 
",reentrancy,3.0,498.0,6.0,2.762979030609131
114,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",reentrancy,3.0,474.0,6.0,2.0171170234680176
115,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",reentrancy,3.0,474.0,6.0,3.085312843322754
116,reentrancy,"YES
The `Collect` function is vulnerable to reentrancy attacks. 

Here's why:

* **External Contract Call:** The `if` statement checks if the balance is sufficient and if the current time is after the `unlockTime`. If it is, the `msg.sender.call.value(_am)()` function is executed. This function call is external to the contract and could be exploited by an attacker.
* **Reentrancy:** The attacker could call the `Collect` function repeatedly, potentially draining the contract's funds. 


Let me know if you'd like a more detailed explanation of how this vulnerability works. 
",reentrancy,3.0,558.0,6.0,2.20701265335083
117,reentrancy,"YES
 
The contract has a reentrancy vulnerability because it allows external calls to be made before the initial execution is complete. This is because the `get()` function calls `transfer()` and `withdrawBalance()` functions. 
",reentrancy,3.0,479.0,6.0,2.588949680328369
118,reentrancy,"YES
 
The code has a reentrancy vulnerability.  The `get()` function calls `transfer` to send a portion of the contract's balance to two different addresses. This creates a window for a malicious actor to call the `withdrawBalance()` function before the `get()` function completes, potentially draining the contract of funds. 
",reentrancy,3.0,501.0,6.0,1.8867900371551514
119,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",reentrancy,3.0,474.0,6.0,2.5688507556915283
120,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",reentrancy,3.0,474.0,6.0,1.749056339263916
121,reentrancy,"YES
 
The code has a reentrancy vulnerability in the `Collect` function.  Here's why:

* **External Contract Calls:** The `Collect` function calls `msg.sender.call.value(_am)()` which is a potential reentrancy vulnerability. 
* **Unclear Execution Flow:** The code doesn't clearly define how the `Collect` function interacts with the external contract. 
* **Potential for Reentrancy:**  The `Collect` function could be called repeatedly by an attacker, leading to a reentrancy attack. 


Let me know if you'd like a more detailed explanation of how this vulnerability works. 
",reentrancy,3.0,559.0,6.0,2.662275791168213
122,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",reentrancy,3.0,474.0,6.0,2.7167904376983643
123,reentrancy,"YES
The `Collect` function is vulnerable to reentrancy attacks. 

Here's why:

* **External Contract Call:** The `if` statement allows the `Collect` function to call an external contract (`msg.sender.call.value(_am)`) before the `acc.balance` is updated.
* **Potential for Reentrancy:**  An attacker could call `Collect` multiple times in rapid succession, potentially draining the contract's funds. 
* **Unclear Execution Flow:** The code lacks clear control flow, making it difficult to determine the exact order of operations and how the contract's state is affected. 


",reentrancy,3.0,558.0,6.0,2.5493831634521484
124,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",reentrancy,3.0,474.0,6.0,2.2677576541900635
125,reentrancy,"YES
 
The contract uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",reentrancy,3.0,474.0,6.0,2.817777395248413
126,reentrancy,"YES
 
The contract has a reentrancy vulnerability because it allows the `withdrawBalance` function to be called again before the previous call is complete. This is because the `get` function calls `withdrawBalance` and then transfers funds to the contract. 
",reentrancy,3.0,486.0,6.0,3.0099875926971436
127,time manipulation,"YES

The contract relies heavily on `block.timestamp` for its functionality, specifically in the `isSaleFinished()` function. This makes it susceptible to manipulation by miners, as they can change the reported timestamp. 
",time manipulation,3.0,476.0,6.0,3.1522786617279053
128,time manipulation,"YES
 
The contract relies heavily on `block.timestamp` for its functionality, making it susceptible to manipulation by miners. This is a classic vulnerability, as miners can adjust the timestamp to their advantage. 
",time manipulation,3.0,473.0,6.0,2.765315294265747
129,time manipulation,"YES
 
The `lastInvestmentTimestamp` variable is directly set to `block.timestamp`, making it susceptible to manipulation by miners. This could allow an attacker to manipulate the timestamp and potentially gain control of the contract. 
",time manipulation,3.0,476.0,6.0,2.374246835708618
130,time manipulation,"YES
 
The contract uses the `now` variable to determine the current block timestamp. This is vulnerable because the `now` variable is not a truly random value. It is determined by the miners, and therefore can be manipulated. 
",time manipulation,3.0,480.0,6.0,2.3532989025115967
131,time manipulation,"YES
 
The contract relies heavily on `block.timestamp` for its functionality, making it vulnerable to manipulation by miners. 
",time manipulation,3.0,457.0,6.0,2.501216173171997
132,short addresses,"YES
 
The contract has a vulnerability related to the `get()` function. It transfers a portion of the contract's balance to two different addresses. This is a classic example of a reentrancy attack. 
",short addresses,2.0,475.0,6.0,2.3791627883911133
133,denial of service,"YES
 
The contract has a vulnerability that allows for a denial of service attack.  The `get()` function transfers a portion of the contract's balance to two different addresses. This can be exploited to drain the contract of funds. 
",denial of service,3.0,481.0,6.0,1.9661238193511963
134,denial of service,"YES
 
The contract has a vulnerability that allows for a denial of service attack.  The `get()` function transfers a portion of the contract's balance to two different addresses. This can be exploited to drain the contract's funds. 
",denial of service,3.0,481.0,6.0,3.0485901832580566
135,denial of service,"YES
 
The code has a vulnerability related to Denial of Service (DoS).  The line `creditorAddresses = new address[](0);` and `creditorAmounts = new uint[](0);`  are vulnerable to DoS attacks.  These lines are used to clear the `creditorAddresses` and `creditorAmounts` arrays.  This can be exploited to cause the contract to crash. 
",denial of service,3.0,519.0,6.0,2.9943971633911133
136,denial of service,"YES
 
The contract has a vulnerability that allows for a denial of service attack.  The `get()` function transfers a portion of the contract's balance to two addresses. This can be exploited to drain the contract of funds. 
",denial of service,3.0,480.0,6.0,2.1215555667877197
137,denial of service,"YES

The contract uses the `get()` function to transfer funds to two different addresses. This function is vulnerable to a Denial of Service attack. 

The contract has a function `ifillArray()` that adds addresses to a list. This function can be used to create a Denial of Service attack by adding a large number of addresses to the list. 
",denial of service,4.0,507.0,6.0,2.200782060623169
138,denial of service,"YES

The code uses a function `get()` that transfers a portion of the contract's balance to two different addresses. This function is designed to drain the contract's funds, leading to a denial of service attack. 
",denial of service,3.0,478.0,6.0,2.3899407386779785
