case_id,vuln_type,audit_report,gt,eval_score,eval_input_token_num,eval_output_token_num,eval_inference_time
11,access control,"YES

The `newOwner` function allows anyone to set themselves as the owner of the contract. This is a classic access control vulnerability. 
",access control,3.0,462.0,6.0,3.547151565551758
12,access control,"YES
 
The contract uses the `keccak256` function to check the code hash. This function is vulnerable to a side-channel attack. 
",access control,2.0,462.0,6.0,2.4540088176727295
13,access control,"YES
The contract uses `msg.sender` to determine the owner. This is a common vulnerability, as it allows anyone to call the contract's functions. 
",access control,3.0,465.0,6.0,2.6277966499328613
14,access control,"YES
 
The `retrieve` function is vulnerable to a reentrancy attack.  Here's why:

* **Reentrancy:**  The `retrieve` function allows for a reentrancy attack by accepting a `code` parameter. 
* **Potential for Manipulation:**  The code checks for a specific `keccak256` hash, which could be manipulated by an attacker to trigger the transfer of funds. 
* **Unintended Behavior:** The code's logic is not clear, and the `if` statement could be exploited to allow for unintended behavior. 


",access control,2.0,549.0,6.0,3.472297430038452
15,access control,"YES
 
The contract uses the `keccak256` function to check the code hash. This function is vulnerable to a side-channel attack.  The attacker can manipulate the code hash to bypass the intended logic. 
",access control,2.0,476.0,6.0,2.812302589416504
16,access control,"YES
 
The `retrieve` function is vulnerable to a reentrancy attack.  Here's why:

* **Unrestricted Access:** The `retrieve` function allows anyone to call it with a `code` parameter. 
* **Potential for Reentrancy:**  The function checks for a specific `keccak256` hash, but it doesn't prevent the attacker from calling the function multiple times. 
* **Unintended Transfer:** The function transfers the entire balance of the contract to the caller if the condition is met. 


Let me know if you'd like to explore other aspects of smart contract security! 
",access control,2.0,555.0,6.0,1.7047014236450195
17,access control,"YES
 
The contract uses `msg.value` to determine if the caller has enough funds to execute the `retrieve` function. This is a common vulnerability as it allows an attacker to manipulate the `msg.value` to bypass the intended logic. 
",access control,2.0,482.0,6.0,2.908437728881836
18,access control,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Unclear Logic:** The `retrieve` function's logic is unclear. It seems to be designed to transfer funds based on a specific condition.
* **Potential for Reentrancy:** The condition `msg.value >= (this.balance - msg.value)` could be exploited by an attacker. 
* **Unintended Behavior:** The code doesn't explicitly handle reentrancy, making it susceptible to attacks. 


Let me know if you'd like to explore other aspects of smart contract security! 
",access control,2.0,550.0,6.0,2.4864838123321533
19,access control,"YES
 
The `retrieve` function is vulnerable to a reentrancy attack.  Here's why:

* **Reentrancy:**  The `retrieve` function allows for a reentrancy attack by accepting a `code` parameter. 
* **Potential for Manipulation:** The `if` statement checks for a specific `keccak256` hash. If an attacker can manipulate the `code` parameter, they can trigger the transfer of funds. 
* **Unintended Behavior:** The `retrieve` function is designed to transfer funds based on the `code` parameter. If the `code` parameter is manipulated, the intended behavior of the contract is compromised. 


",access control,2.0,569.0,6.0,2.6555721759796143
20,access control,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Unrestricted Access:** The `retrieve` function allows anyone to call it with a specific `code` input.
* **Potential for Reentrancy:**  The code checks for a specific `code` input, but doesn't prevent a malicious actor from repeatedly calling the function with different inputs. 
* **Unintended Transfer:** The function transfers the balance to the caller if the condition is met. 


Let me know if you'd like to explore other aspects of smart contract security! 
",access control,2.0,550.0,6.0,2.1839003562927246
21,access control,"YES
 
The contract uses `msg.value` to determine the amount of Ether sent. This can be exploited by an attacker to send a large amount of Ether to the contract. 
",access control,2.0,469.0,6.0,2.8444201946258545
22,access control,"YES
 
The `retrieve` function is vulnerable to a reentrancy attack.  Here's why:

* **Reentrancy:**  The `retrieve` function allows an attacker to call it repeatedly, potentially draining the contract's funds. 
* **Potential for Exploitation:** The `if` statement checks for a specific condition, but it doesn't prevent the attacker from calling the function multiple times. 
* **Unintended Behavior:** The code doesn't handle the possibility of multiple calls to the `retrieve` function. 


Let me know if you'd like to explore other aspects of smart contract security! 
",access control,2.0,554.0,6.0,4.273994445800781
23,access control,"YES
 
The contract uses the `msg.value` to determine the amount of funds to transfer. This can be exploited by an attacker to drain the contract of funds. 
",access control,2.0,467.0,6.0,2.2781777381896973
24,access control,"YES
 
The contract's `retrieve` function allows for arbitrary code execution by accepting a string as input and then using `keccak256` to hash it. This allows an attacker to craft a malicious code that would execute when the `retrieve` function is called. 
",access control,2.0,487.0,6.0,2.555894613265991
25,access control,"YES
 
The `retrieve` function is vulnerable to a reentrancy attack.  Here's why:

* **Reentrancy:**  The `retrieve` function allows for a reentrancy attack by accepting a `code` parameter. 
* **Potential for Manipulation:**  The code checks for a specific `keccak256` hash, which could be manipulated by an attacker to trigger the transfer of funds. 
* **Unintended Behavior:** The `retrieve` function's logic is not clear, and it's possible that it could be exploited to transfer funds to an attacker. 


",access control,2.0,552.0,6.0,2.879387378692627
26,access control,"YES

The contract uses `fibonacciLibrary.delegatecall` to execute functions. This is a potential vulnerability because it allows an attacker to call arbitrary functions on the contract. 
",access control,3.0,468.0,6.0,2.5860202312469482
27,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Low-Level Calls:** The `retrieve` function uses `adr.call.value(msg.value)(data)` to execute a function on the target address. This is a low-level call that doesn't propagate errors.
* **Potential for Reentrancy:**  An attacker could call `retrieve` multiple times, each time attempting to execute the same function on the target address.  This could lead to a reentrancy attack, where the attacker exploits the vulnerability to drain funds. 
* **Lack of Error Handling:** The `retrieve` function doesn't handle potential errors from the target address's function. 


Let me know if you'd like to explore other aspects of smart contract security! 
",unchecked low level calls,4.0,590.0,6.0,3.688384771347046
28,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Unclear Logic:** The function's logic is unclear. It seems to be designed to transfer funds based on a specific condition.
* **Potential for Reentrancy:** The `msg.value >= (this.balance - msg.value)` condition could be exploited by an attacker. 
* **Unintended Behavior:** The code doesn't explicitly handle reentrancy, making it susceptible to attacks. 


",unchecked low level calls,2.0,534.0,6.0,2.353212594985962
29,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Reentrancy:**  The `retrieve` function allows an attacker to call the `GetFreebie` function repeatedly, potentially draining the contract's funds. 
* **Unprotected `call`:** The `call` function is not protected against reentrancy. 
* **Potential for Overflow:** The `retrieve` function does not check for overflow or underflow. 


Let me know if you'd like to explore other aspects of smart contract security! 
",unchecked low level calls,2.0,547.0,6.0,2.9139866828918457
30,unchecked low level calls,"YES
 
The code has several vulnerabilities:

* **Low-level function calls:** The `send()` function is vulnerable to reentrancy attacks. 
* **Unchecked return values:** The code does not check the return values of low-level functions, which can lead to unexpected behavior.
* **Unprotected access:** The `transferOwnership` function allows anyone to change the contract's owner. 
* **Unclear logic:** The `retrieve` function is unclear and could be exploited. 
* **Potential for reentrancy:** The `claimThrone` function could be vulnerable to reentrancy attacks. 



",unchecked low level calls,4.0,557.0,6.0,2.3122878074645996
31,unchecked low level calls,"YES

The contract uses `retrieve` function which takes a string as input and then calls a function with the same input. This is a potential vulnerability because it allows an attacker to potentially execute arbitrary code. 
",unchecked low level calls,2.0,477.0,6.0,3.1084721088409424
32,unchecked low level calls,"YES
 
 The code uses `msg.value` to determine the amount of funds sent. This can be exploited by attackers to send a large amount of funds to the contract. 
 
 The code also uses `msg.sender` to determine the sender of the funds. This can be exploited by attackers to send funds to the contract. 
 
 The code also uses `this.balance` to determine the balance of the contract. This can be exploited by attackers to send funds to the contract. 
 
 The code also uses `keccak256(code)` to determine the hash of the code. This can be exploited by attackers to send funds to the contract. 
 
 The code also uses `bytes5(keccak256(code))` to determine the hash of the code. This can be exploited by attackers to send funds to the contract. 
 
 The code also uses `getHashOfBlock(blockIndex)` to determine the hash of the block. This can be exploited by attackers to send funds to the contract. 
 
 The code also uses `block.number` to determine the number of the block. This can be exploited by attackers to send funds to the contract. 
 
 The code also uses `block.blockhash(blockIndex)` to determine the hash of the block. This can be exploited by attackers to send funds to the contract. 
 
 The",unchecked low level calls,2.0,697.0,6.0,2.6319217681884766
33,unchecked low level calls,"YES

The contract uses `callchecked` and `callnotchecked` functions. These functions call the `callee` address without any checks. This can lead to reentrancy attacks and other vulnerabilities. 
",unchecked low level calls,4.0,477.0,6.0,2.539445638656616
34,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Uncontrolled Execution:** The `retrieve` function allows the caller to execute arbitrary code. 
* **Potential for Reentrancy:**  An attacker could call `retrieve` multiple times, potentially leading to a reentrancy attack. 
* **Unpredictable Behavior:** The code's behavior is not predictable, as it relies on the `msg.value` and `bytes5` comparison. 


Let me know if you'd like to explore other aspects of smart contract security! 
",unchecked low level calls,2.0,551.0,6.0,3.6411921977996826
35,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Unclear Logic:** The function's logic is unclear. It seems to be designed to transfer funds based on a condition, but the exact conditions are not clear.
* **Potential for Reentrancy:** The function's logic could be manipulated to allow an attacker to repeatedly call the function and drain the contract of funds. 
* **Lack of Safeguards:** The function does not include any safeguards to prevent reentrancy attacks. 


",unchecked low level calls,2.0,545.0,6.0,4.103995323181152
36,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  The `if` statement checks if the `msg.value` is greater than the `this.balance - msg.value`. If it is, the function will transfer the remaining balance to the sender. This can be exploited by an attacker to drain the contract of funds. 
",unchecked low level calls,2.0,504.0,6.0,3.561880111694336
37,unchecked low level calls,"YES

The `retrieve` function is vulnerable to a reentrancy attack. 

Here's why:

* **Uncontrolled Reentrancy:** The `retrieve` function allows the attacker to call the `transfer` function repeatedly, potentially draining the contract's funds. 
* **Potential for Overflow:** The `msg.value` calculation could be manipulated to trigger a reentrancy attack. 
* **Lack of Safeguards:** The `if` statement in the `retrieve` function does not adequately address the potential for reentrancy. 


",unchecked low level calls,2.0,545.0,6.0,2.3470230102539062
38,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Unprotected `msg.value`:** The `retrieve` function doesn't check the `msg.value` before it's used to calculate the balance. This means an attacker could potentially send a large amount of Ether to the contract, and then call `withdraw` repeatedly to drain the contract. 
* **Potential for Reentrancy:** The `withdraw` function is vulnerable to reentrancy attacks. 


Let me know if you'd like to explore other aspects of smart contract security! 
",unchecked low level calls,2.0,550.0,6.0,2.930047035217285
39,unchecked low level calls,"YES
 
The code uses `call.value` and `gas` functions, which are low-level functions that can be exploited.  The `call.value` function can be used to send a value to an address, and the `gas` function can be used to set the gas limit for a function call. These functions can be used to send a large amount of gas to an address, which can be used to drain the contract of funds. 
",unchecked low level calls,4.0,525.0,6.0,3.3631749153137207
40,unchecked low level calls,"YES
 
The `execute` function calls a target contract with `_dst.call.value(_value)(_data)`. This is a low-level call that does not propagate errors.  The `_dst` contract can fail, and the execution will continue. 
",unchecked low level calls,3.0,485.0,6.0,3.179821729660034
41,unchecked low level calls,"YES
 
The `execute` function allows arbitrary code execution. This is a major security vulnerability.  The `_dst.call.value(_value)(_data)` line is a low-level call that doesn't propagate errors. This means that if the function call fails, the contract will continue to execute, potentially leading to unexpected behavior and potential exploits. 
",unchecked low level calls,3.0,502.0,6.0,3.9709649085998535
42,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Unclear Logic:** The `retrieve` function's logic is unclear. It seems to be designed to transfer funds based on a condition, but the condition is not well-defined.
* **Potential for Reentrancy:** The `if` statement checks if the `msg.value` is greater than the balance minus the `msg.value`. This could be exploited by an attacker to repeatedly call the `retrieve` function and drain the contract's funds. 
* **Lack of Safeguards:** The function doesn't include any safeguards to prevent reentrancy. 


",unchecked low level calls,2.0,568.0,6.0,2.6727294921875
43,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Uncontrolled Execution:** The `retrieve` function allows for external code execution. 
* **Potential for Reentrancy:**  An attacker could call `retrieve` multiple times, potentially executing malicious code within the contract. 
* **Unpredictable Behavior:** The `bytes5(keccak256(code)) == 0x70014a63ef` check is not sufficient to prevent reentrancy. 


Let me know if you'd like to explore other aspects of smart contract security! 
",unchecked low level calls,2.0,554.0,6.0,2.629345655441284
44,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Reentrancy:**  The `retrieve` function allows an attacker to call the `GetFreebie` function repeatedly, potentially draining the contract's funds. 
* **Unprotected `call`:** The `call` function is not protected against reentrancy. 
* **Potential for Overflow:** The `retrieve` function does not check for overflow or underflow. 


Let me know if you'd like to explore other aspects of smart contract security! 
",unchecked low level calls,2.0,547.0,6.0,2.187835693359375
45,unchecked low level calls,"YES
 
The `_dst.call.value(_value)(_data);` line is vulnerable because it uses the `call.value` function. This function does not propagate errors, meaning that if the call fails, the contract will continue to execute. This can lead to unexpected behavior and potential vulnerabilities. 
",unchecked low level calls,3.0,493.0,6.0,2.562810182571411
46,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Uncontrolled Execution:** The `retrieve` function allows external code execution. 
* **Potential for Reentrancy:**  An attacker could call `retrieve` multiple times, potentially leading to a loop where the contract keeps executing the same code. 
* **Unintended Transfers:** The code's logic is unclear, but it appears to transfer funds based on a specific condition. This condition could be exploited by an attacker. 


Let me know if you'd like to explore other aspects of smart contract security! 
",unchecked low level calls,2.0,557.0,6.0,2.055198907852173
47,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  The function calls `WithdrawToken` with the `to` address and `amount` as parameters.  The `WithdrawToken` function is a low-level call that does not propagate errors.  This means that an attacker could call `withdraw` multiple times, draining the contract of funds. 
",unchecked low level calls,2.0,510.0,6.0,2.506354808807373
48,unchecked low level calls,"YES

The contract uses `caddress.call(id,from,_tos[i],v[i])` to call external contracts. This is a low-level call that does not propagate errors. If the call fails, the contract will continue to execute, potentially leading to unexpected behavior and vulnerabilities. 
",unchecked low level calls,3.0,493.0,6.0,2.26021671295166
49,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Unclear Logic:** The `retrieve` function's logic is unclear. It appears to be designed to transfer funds based on a condition, but the exact conditions are not explicitly defined.
* **Potential for Reentrancy:** The function's behavior is susceptible to reentrancy attacks.  An attacker could potentially call the `retrieve` function multiple times within a short period, leading to a loss of funds. 
* **Lack of Safeguards:** The function lacks any safeguards to prevent reentrancy. 


",unchecked low level calls,2.0,560.0,6.0,3.1548752784729004
50,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Unclear Logic:** The `retrieve` function's logic is unclear. It appears to be designed to transfer funds based on a condition, but the exact conditions are not explicitly defined.
* **Potential for Reentrancy:** The function's behavior is susceptible to reentrancy attacks. An attacker could potentially call the `retrieve` function multiple times within a short period, leading to a loss of funds. 
* **Lack of Safeguards:** The function lacks any safeguards to prevent reentrancy. 


",unchecked low level calls,2.0,559.0,6.0,2.582401752471924
51,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Unclear Logic:** The `retrieve` function's logic is unclear. It seems to be designed to transfer funds based on a specific condition.
* **Potential for Reentrancy:** The `if` statement checks for a specific condition, but the code doesn't explicitly handle the possibility of a reentrancy attack. 
* **Unintended Behavior:** The code could be vulnerable to reentrancy attacks if an attacker can call the `retrieve` function multiple times in rapid succession. 


Let me know if you'd like to explore other aspects of smart contract security! 
",unchecked low level calls,2.0,569.0,6.0,2.302504301071167
52,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Unprotected `msg.value`:** The `retrieve` function relies on the `msg.value` to determine if the transfer is successful. This is a potential vulnerability because the attacker can manipulate the `msg.value` to trigger the transfer.
* **Unprotected `caddress.call`:** The `caddress.call` function is vulnerable to reentrancy attacks because it does not check for the return value of the function. 


Let me know if you'd like to explore other aspects of smart contract security! 
",unchecked low level calls,2.0,557.0,6.0,2.8584163188934326
53,unchecked low level calls,"YES
 
The `retrieve` function allows for arbitrary code execution by accepting a string as input and then calling the `code` function with the provided string. This is a classic example of a code injection vulnerability. 
",unchecked low level calls,2.0,478.0,6.0,3.0454154014587402
54,unchecked low level calls,"YES

The contract uses `caddress.call(id,from,_tos[i],v)` which is a low-level call. This can lead to unexpected behavior and potential vulnerabilities. 
",unchecked low level calls,3.0,471.0,6.0,2.0864837169647217
55,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Unclear Logic:** The function's logic is unclear. It seems to be designed to transfer funds based on a condition, but the condition is not explicitly defined.
* **Potential for Reentrancy:** The `if` statement checks if the `msg.value` is greater than the balance minus the `msg.value`. This could be exploited by an attacker to repeatedly call the function and drain the contract. 
* **Lack of Safeguards:** The code lacks any safeguards to prevent reentrancy. 


",unchecked low level calls,2.0,559.0,6.0,2.5649209022521973
56,unchecked low level calls,"YES

The `retrieve` function is vulnerable to reentrancy attacks. 

Here's why:

* **Unrestricted `fuck.call`:** The `fuck.call` function is called without any checks for the return value. This means an attacker could potentially call the function multiple times, draining the contract's funds.
* **Potential for Reentrancy:** The `retrieve` function accepts a string `code` and uses it to call `fuck.call`. If the `code` is malicious, an attacker could exploit this vulnerability to drain the contract's funds. 


",unchecked low level calls,2.0,548.0,6.0,3.294665575027466
57,unchecked low level calls,"YES

The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Uncontrolled Execution:** The `retrieve` function allows the caller to execute arbitrary code. 
* **Reentrancy Vulnerability:**  An attacker could call `retrieve` multiple times, potentially draining the contract's funds. 
* **Lack of Safeguards:** The code lacks any checks to prevent the attacker from repeatedly calling `retrieve` and draining the contract. 


",unchecked low level calls,2.0,532.0,6.0,3.1973421573638916
58,unchecked low level calls,"YES

The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Unrestricted Access:** The `retrieve` function allows anyone to call it with a `code` input.
* **Potential for Reentrancy:**  The `retrieve` function could be exploited by an attacker to call the `transfer` function multiple times, draining the contract's funds. 
* **Lack of Safeguards:** The `retrieve` function doesn't have any safeguards to prevent reentrancy. 


",unchecked low level calls,2.0,540.0,6.0,2.681114435195923
59,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Unclear Logic:** The `retrieve` function's logic is unclear. It seems to be designed to transfer funds based on a condition, but the exact conditions are not clear.
* **Potential for Reentrancy:** The function's logic could be manipulated to allow an attacker to repeatedly call the function and drain the contract of funds. 
* **Lack of Safeguards:** The function lacks any safeguards to prevent reentrancy. 


",unchecked low level calls,2.0,545.0,6.0,3.3385932445526123
60,unchecked low level calls,"YES

The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Unrestricted Access:** The `retrieve` function allows anyone to call it with a specific `code` input.
* **Potential for Reentrancy:**  The `callAddress` function is vulnerable to reentrancy attacks. 
* **Unintended Execution:** The `retrieve` function could be exploited to call `callAddress` repeatedly, potentially draining funds. 


",unchecked low level calls,2.0,531.0,6.0,2.5211119651794434
61,unchecked low level calls,"YES
 
The `callFirstTarget` and `callSecondTarget` functions call external contracts with a value.  This can be a vulnerability if the external contract is not properly audited. 
",unchecked low level calls,3.0,473.0,6.0,3.1015121936798096
62,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  The `if` statement checks if the `msg.value` is greater than the balance minus the `msg.value`. If it is, it then checks if the `keccak256(code)` is equal to `0x70014a63ef`. This is a potential reentrancy vulnerability because the `msg.value` can be manipulated by an attacker. 
",unchecked low level calls,2.0,523.0,6.0,2.1158454418182373
63,unchecked low level calls,"YES

The `retrieve` function is vulnerable to reentrancy attacks. 

Here's why:

* **Unrestricted `msg.value`:** The `retrieve` function allows the caller to send any amount of Ether, potentially exceeding the contract's balance.
* **Conditional Transfer:** The `if` statement checks if the `msg.value` is sufficient to cover the balance minus the `msg.value`. 
* **Potential Reentrancy:** If an attacker can call `retrieve` multiple times, they can potentially drain the contract's funds. 


Let me know if you'd like to explore other aspects of smart contract security! 
",unchecked low level calls,2.0,559.0,6.0,1.787447214126587
64,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Uncontrolled Execution:** The `retrieve` function allows the caller to execute arbitrary code. 
* **Reentrancy Vulnerability:**  An attacker could call `retrieve` multiple times, potentially draining the contract's funds. 
* **Lack of Safeguards:** The code doesn't include any safeguards to prevent reentrancy. 


",unchecked low level calls,2.0,524.0,6.0,2.994123935699463
65,unchecked low level calls,"YES

The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Unrestricted `msg.value`:** The `retrieve` function accepts `msg.value` which can be manipulated by an attacker.
* **Potential for Reentrancy:** The `retrieve` function allows an attacker to call the `transfer` function multiple times, potentially draining the contract's funds. 


Let me know if you'd like to explore other aspects of smart contract security! 
",unchecked low level calls,2.0,531.0,6.0,2.866459846496582
66,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Unprotected `msg.value`:** The `retrieve` function doesn't check the `msg.value` before it's used to calculate the balance. This means an attacker could potentially send a large amount of Ether to the contract, and then call `withdraw` repeatedly to drain the contract. 
* **Potential for Reentrancy:** The `withdraw` function is vulnerable to reentrancy attacks. 


Let me know if you'd like to explore other aspects of smart contract security! 
",unchecked low level calls,2.0,550.0,6.0,2.604262113571167
67,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Unclear Logic:** The function's logic is unclear. It seems to be designed to transfer funds based on a specific condition.
* **Potential for Reentrancy:** The `if` statement checks for a condition, but the code doesn't explicitly handle the possibility of a reentrancy attack. 
* **Unintended Behavior:** The code could be vulnerable to reentrancy attacks if an attacker can call the `retrieve` function multiple times before the transfer is completed. 


",unchecked low level calls,2.0,552.0,6.0,2.980783462524414
68,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Unrestricted External Call:** The `retrieve` function allows external calls to be made with the `msg.value` parameter.
* **Potential for Reentrancy:** An attacker could call the `retrieve` function multiple times, potentially draining the contract's funds. 
* **Lack of Safeguards:** The code doesn't include any safeguards to prevent reentrancy. 


",unchecked low level calls,2.0,531.0,6.0,2.3890883922576904
69,unchecked low level calls,"YES

The `retrieve` function is vulnerable to reentrancy attacks. 

Here's why:

* **Unrestricted `msg.value`:** The `retrieve` function allows the caller to send any amount of Ether, potentially exceeding the contract's balance.
* **Conditional Transfer:** The function checks if the `msg.value` is sufficient to cover the balance minus the `msg.value`. If it is, it transfers the remaining balance to the caller.
* **Potential Reentrancy:**  An attacker could call `retrieve` multiple times, each time with a different `code` input, potentially draining the contract's funds. 


Let me know if you'd like to explore other aspects of smart contract security! 
",unchecked low level calls,2.0,576.0,6.0,2.7682108879089355
70,unchecked low level calls,"YES

The contract uses `caddress.call(id,from,_tos[i],v[i])` which is a low-level call. This can lead to unexpected behavior and potential vulnerabilities. 
",unchecked low level calls,3.0,473.0,6.0,2.058015823364258
71,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  The `if` statement checks for a specific condition, but the `bytes5` function call is not properly handled. This can lead to an attacker calling the function repeatedly, draining the contract of funds. 
",unchecked low level calls,2.0,493.0,6.0,2.2999489307403564
72,unchecked low level calls,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Uncontrolled Execution:** The `retrieve` function allows the caller to execute arbitrary code. 
* **Reentrancy Vulnerability:**  An attacker could call `retrieve` multiple times, potentially leading to a situation where the contract's internal logic is manipulated. 
* **Potential for Loss:** The attacker could exploit this vulnerability to drain funds from the contract. 


",unchecked low level calls,2.0,529.0,6.0,2.3686225414276123
73,front running,"YES
 
The `retrieve` function is vulnerable to front-running attacks.  It allows users to pay a fee to have their transactions mined more quickly, and then uses a specific code hash to transfer the funds to the user. This can be exploited by malicious users to steal the solution to a puzzle or other valuable secret. 
",front running,3.0,498.0,6.0,2.158698081970215
74,front running,"YES
 
The contract uses a `retrieve` function that accepts a string `code` and a `msg.value` to determine the balance of the contract.  The `retrieve` function then checks if the `msg.value` is greater than the balance of the contract minus the `msg.value`. If this condition is met, the contract will transfer the balance of the contract to the sender. This function is vulnerable to front-running attacks. 
",front running,3.0,521.0,6.0,2.3431761264801025
75,front running,"YES
 
The contract's `retrieve` function allows users to specify a code snippet and pay a fee to execute it. This opens the door for front-running attacks, where malicious users can exploit the contract's execution to gain an unfair advantage. 
",front running,3.0,482.0,6.0,2.3481171131134033
76,front running,"YES
 
The contract's `retrieve` function allows for front-running attacks.  The `bytes5(keccak256(code)) == 0x70014a63ef` check is a common technique used to identify and exploit vulnerabilities in smart contracts. 
",front running,3.0,485.0,6.0,1.8729369640350342
77,arithmetic,"YES

The `retrieve` function uses a `bytes5` comparison with a hash of the input `code`. This could be a potential attack vector for an overflow. 
",arithmetic,2.0,467.0,6.0,2.5957887172698975
78,arithmetic,"YES
 
The `retrieve` function has a potential for integer overflow.  The `if` statement checks if the `msg.value` is greater than the balance minus the `msg.value`. This could lead to an overflow if the `msg.value` is large enough. 
",arithmetic,3.0,487.0,6.0,2.543388843536377
79,arithmetic,"YES

The `retrieve` function has a potential vulnerability related to integer overflows.  The code checks if the `msg.value` is greater than the balance minus the `msg.value`. If this condition is true, it then checks if the hash of the `code` is equal to a specific value. If it is, the contract transfers the balance to the sender. 

This could lead to an overflow if the `msg.value` is large enough. 
",arithmetic,3.0,525.0,6.0,2.4989538192749023
80,arithmetic,"YES

The `retrieve` function has a potential for integer overflow.  The `if` statement checks if the `msg.value` is greater than the balance minus the `msg.value`. This could lead to an overflow if the `msg.value` is large enough. 
",arithmetic,3.0,487.0,6.0,2.309802770614624
81,arithmetic,"YES
 
 The `retrieve` function is vulnerable to integer overflows and underflows.  The `bytes5` function is used to check if the code hash matches a specific value. If the `bytes5` function is not properly implemented, it could lead to integer overflows and underflows. 
",arithmetic,4.0,493.0,6.0,2.119119167327881
82,arithmetic,"YES

The `retrieve` function is vulnerable to integer overflows and underflows.  The `if` statement checks if the `msg.value` is greater than the balance minus the `msg.value`. If this condition is true, it then checks if the hash of the `code` matches a specific value. This could lead to an overflow if the `msg.value` is large enough. 
",arithmetic,3.0,512.0,6.0,3.0714364051818848
83,arithmetic,"YES

The `retrieve` function uses a `bytes5` comparison with a hash of the input code. This is a potential vulnerability because it allows an attacker to manipulate the code and potentially execute malicious code. 
",arithmetic,2.0,475.0,6.0,1.7418386936187744
84,arithmetic,"YES

The code uses a function `retrieve` that accepts a string as input. This function then calls a function `run` with an integer input. The `run` function performs a subtraction operation, which could potentially lead to an integer overflow if the input value is large enough. 
",arithmetic,3.0,490.0,6.0,2.976985216140747
85,arithmetic,"YES

The `retrieve` function uses a `keccak256` hash to check if the input code matches a specific pattern. If it does, it transfers the balance of the contract to the sender. This function is vulnerable to integer overflows because it performs arithmetic operations on the `count` variable. 
",arithmetic,4.0,494.0,6.0,2.282296895980835
86,arithmetic,"YES
 
The contract uses unsigned integers and has functions that perform arithmetic operations.  The `overflowaddtostate`, `overflowmultostate`, `underflowtostate`, `overflowlocalonly`, `overflowmulocalonly`, and `underflowlocalonly` functions can lead to integer overflows and underflows, which can be exploited to drain the contract of funds. 
",arithmetic,4.0,510.0,6.0,5.130553245544434
87,arithmetic,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  It allows an attacker to repeatedly call the function and drain the contract of funds. 
",arithmetic,2.0,465.0,6.0,3.25335955619812
88,arithmetic,"YES

The `retrieve` function has a potential for integer overflow.  The `if` statement checks if the `msg.value` is greater than the balance minus the `msg.value`. This could lead to an overflow if the `msg.value` is large enough. 
",arithmetic,3.0,487.0,6.0,2.024747371673584
89,arithmetic,"YES

The `add` function is vulnerable to integer overflows.  The line `sellerBalance += value;`  can cause an overflow if the `value` is too large. 
",arithmetic,3.0,471.0,6.0,1.8667564392089844
90,arithmetic,"YES

The `retrieve` function is vulnerable to integer overflows and underflows.  The `if` statement checks if the `msg.value` is greater than the balance minus the `msg.value`. This can lead to overflows if the `msg.value` is large enough. 
",arithmetic,3.0,490.0,6.0,3.5997180938720703
91,bad randomness,"YES
 
The contract relies on the blockhash function, which is predictable.  This means that an attacker could potentially calculate the hash of the block and then manipulate the contract to give them the desired outcome. 
",bad randomness,3.0,475.0,6.0,3.5446665287017822
92,bad randomness,"YES
 
 The code uses `block.number` to generate random numbers for the raffle. This is a major security vulnerability because it's predictable and can be manipulated by miners. 
",bad randomness,3.0,467.0,6.0,2.85280442237854
93,bad randomness,"YES
The code uses a function `rand` that relies on the block hash and a constant factor. This makes it susceptible to attacks where the attacker can manipulate the block hash to influence the random number. 
",bad randomness,3.0,475.0,6.0,2.961698293685913
94,bad randomness,"YES
 
The code uses a function `retrieve` that accepts a string as input and then uses a hash function to check if the input matches a specific pattern. This pattern is hardcoded and can be manipulated by an attacker. 
",bad randomness,2.0,479.0,6.0,2.15592622756958
95,bad randomness,"YES
 
The contract uses `keccak256` to generate a random number, but the `keccak256` function itself is not truly random.  The contract's `guess` function relies on the `keccak256` function to generate a random number, but the `keccak256` function itself is not truly random.  This makes the contract vulnerable to attacks. 
",bad randomness,3.0,510.0,6.0,2.451683759689331
96,bad randomness,"YES
 
The contract uses a predictable random number generator. The `random` function relies on the `block.number` and `block.timestamp` which are both predictable values. This makes the generated random number susceptible to manipulation and attacks. 
",bad randomness,3.0,480.0,6.0,2.3626537322998047
97,reentrancy,"YES
The `Collect` function is vulnerable to reentrancy attacks.  Here's why:

* **External Contract Call:** The `Collect` function calls `msg.sender.call.value(_am)()` which is a call to an external contract.
* **Potential for Reentrancy:**  This call to an external contract could be re-entered by the attacker, leading to a chain of calls that drain the contract's funds. 


Let me know if you'd like a more detailed explanation of how this vulnerability works. 
",reentrancy,3.0,538.0,6.0,2.7545883655548096
98,reentrancy,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Uncontrolled External Calls:** The `retrieve` function allows external calls to be made with the `msg.value` parameter. 
* **Potential for Reentrancy:**  An attacker could call the `retrieve` function multiple times, potentially leading to a reentrancy attack. 
* **Unclear Logic:** The code doesn't clearly define the conditions for the `msg.value` parameter to be transferred. 


Let me know if you'd like to explore other aspects of smart contract security! 
",reentrancy,3.0,552.0,6.0,4.013531684875488
99,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",reentrancy,3.0,474.0,6.0,2.659902811050415
100,reentrancy,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **External Contract Call:** The `retrieve` function allows external contracts to call the `msg.sender` contract.
* **Uncontrolled Execution:** The `if` statement checks if the `msg.value` is sufficient to cover the balance of the contract. If it is, the `bytes5(keccak256(code)) == 0x70014a63ef` condition is met. 
* **Potential for Reentrancy:**  The `bytes5` function checks if the `keccak256(code)` matches a specific value. If the attacker can manipulate the `code` to match this value, they can trigger the transfer of funds. 


Let me know if you'd like a more detailed explanation of how this vulnerability works. 
",reentrancy,3.0,602.0,6.0,3.4096431732177734
101,reentrancy,"YES

The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Unrestricted External Calls:** The `retrieve` function allows external calls to be made to the contract's internal functions.
* **Potential for Reentrancy:**  An attacker could call the `retrieve` function multiple times, potentially leading to a reentrancy attack. 
* **Uncontrolled Execution:** The `retrieve` function doesn't have any checks to prevent the execution of external calls before the initial execution is complete. 


",reentrancy,3.0,540.0,6.0,1.565633773803711
102,reentrancy,"YES
 
The contract uses `msg.sender.call.value(_am)()` in the `Collect` function. This line allows an attacker to call the `Collect` function repeatedly, draining the contract of funds. This is a classic reentrancy vulnerability. 
",reentrancy,3.0,485.0,6.0,2.9750776290893555
103,reentrancy,"YES
 
The code has a reentrancy vulnerability in the `Collect` function.  Here's why:

* **External Contract Calls:** The `Collect` function calls `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. 
* **Reentrancy:** This creates a reentrancy vulnerability because the contract's state can be changed in the middle of its execution. 


Let me know if you'd like a more detailed explanation of how this vulnerability works. 
",reentrancy,3.0,539.0,6.0,3.4800162315368652
104,reentrancy,"YES

The `retrieve` function allows for a reentrancy attack.  The function can be called repeatedly, potentially leading to a reentrancy attack. 
",reentrancy,3.0,467.0,6.0,2.772995948791504
105,reentrancy,"YES
 
The `Collect` function is vulnerable to reentrancy attacks.  Here's why:

* **External Contract Calls:** The `Collect` function calls `msg.sender.call.value(_am)()` which is a call to an external contract.
* **Potential for Reentrancy:**  The `Collect` function could be called repeatedly by an attacker, leading to a reentrancy attack. 


Let me know if you'd like a more detailed explanation of how this vulnerability works. 
",reentrancy,3.0,531.0,6.0,2.1625609397888184
106,reentrancy,"YES
 
The code has a reentrancy vulnerability in the `Collect` function.  Here's why:

* **Uncontrolled External Calls:** The `Collect` function allows external calls to be made within the contract.
* **Potential for Reentrancy:**  An attacker could call `Collect` multiple times within a short period, potentially draining the contract's funds. 
* **Lack of Safeguards:** The code doesn't have any mechanisms to prevent or detect repeated calls to `Collect`. 


Let me know if you'd like to explore other aspects of smart contract security! 
",reentrancy,3.0,550.0,6.0,2.5417251586914062
107,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy attack. 
",reentrancy,3.0,474.0,6.0,2.2436745166778564
108,reentrancy,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Uncontrolled External Calls:** The `retrieve` function allows external calls to be made to the contract.
* **Potential for Reentrancy:**  The `retrieve` function could be called repeatedly by an attacker, leading to a reentrancy attack. 
* **Unclear Logic:** The logic of the `retrieve` function is unclear. 


",reentrancy,4.0,525.0,6.0,2.6872808933258057
109,reentrancy,"YES

The contract uses a `supportsToken` function that calls `ModifierEntrancy`'s `airDrop` function. This creates a reentrancy vulnerability because the `airDrop` function can be called repeatedly before the `supportsToken` function completes. 
",reentrancy,3.0,488.0,6.0,2.6230690479278564
110,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",reentrancy,3.0,474.0,6.0,2.313063383102417
111,reentrancy,"YES
 
The code has a reentrancy vulnerability in the `Collect` function.  Here's why:

* **Uncontrolled External Calls:** The `Collect` function allows external calls to be made within the contract.
* **Potential for Reentrancy:**  An attacker could call `Collect` multiple times within a short period, potentially draining the contract's funds. 
* **Lack of Safeguards:** The code doesn't have any safeguards to prevent this type of attack. 


Let me know if you'd like to explore other aspects of smart contract security! 
",reentrancy,3.0,547.0,6.0,2.0792148113250732
112,reentrancy,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Unrestricted External Calls:** The `retrieve` function allows external calls to the contract, potentially leading to a reentrancy attack.
* **Potential for Uncontrolled Execution:** The `retrieve` function's logic doesn't explicitly handle reentrancy.  An attacker could call the `retrieve` function multiple times, potentially leading to a reentrancy attack. 
* **Unclear Logic:** The `retrieve` function's logic is unclear.  It's unclear how the `bytes5` function is used to determine the code's hash. 


",reentrancy,4.0,563.0,6.0,2.4583635330200195
113,reentrancy,"YES
 
The `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **External Contract Call:** The `retrieve` function calls an external contract (`bytes5(keccak256(code)) == 0x70014a63ef`)  which could be malicious.
* **Potential for Reentrancy:**  The `if` statement checks if the `msg.value` is greater than the contract's balance minus the `msg.value`. If the attacker can manipulate the `msg.value` to trigger the `if` statement, they can potentially execute malicious code. 
 
Let me know if you'd like a more detailed explanation of how this vulnerability works. 
",reentrancy,3.0,570.0,6.0,2.2891530990600586
114,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",reentrancy,3.0,474.0,6.0,1.9128541946411133
115,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy attack. 
",reentrancy,3.0,474.0,6.0,4.0774922370910645
116,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",reentrancy,3.0,474.0,6.0,3.0109565258026123
117,reentrancy,"YES
 
The contract's `retrieve` function is vulnerable to reentrancy attacks.  Here's why:

* **Unrestricted External Calls:** The `retrieve` function allows external calls to be made to the contract.
* **Potential for Reentrancy:**  The `retrieve` function's logic could be exploited by an attacker to call the `transfer` function repeatedly, draining the contract's funds. 
* **Unclear Logic:** The `retrieve` function's logic is unclear. It's unclear what the `bytes5(keccak256(code)) == 0x70014a63ef` condition is doing. 


",reentrancy,4.0,560.0,6.0,2.7367100715637207
118,reentrancy,"YES
 
The code has a reentrancy vulnerability.  The `retrieve` function allows an attacker to call the `addToBalance` function repeatedly, potentially draining the contract's funds. 
",reentrancy,3.0,473.0,6.0,2.2777836322784424
119,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",reentrancy,3.0,474.0,6.0,2.7581841945648193
120,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",reentrancy,3.0,474.0,6.0,3.531780242919922
121,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",reentrancy,3.0,474.0,6.0,2.5972752571105957
122,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",reentrancy,3.0,474.0,6.0,2.405900716781616
123,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",reentrancy,3.0,474.0,6.0,2.189120054244995
124,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",reentrancy,3.0,474.0,6.0,2.9725661277770996
125,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",reentrancy,3.0,474.0,6.0,2.560728073120117
126,reentrancy,"YES
 
The contract allows for a reentrancy attack because it calls `withdrawBalance` again before the initial execution is complete. 
",reentrancy,3.0,461.0,6.0,4.666256666183472
127,time manipulation,"NO 
",time manipulation,1.0,435.0,6.0,2.3782501220703125
128,time manipulation,"YES
 
The contract uses `block.timestamp` in the `randomGen` function, which is vulnerable to manipulation by miners. 
",time manipulation,3.0,459.0,6.0,3.440284013748169
129,time manipulation,"YES
 
The contract relies heavily on `block.timestamp` for its functionality. This makes it susceptible to manipulation by miners, as they can adjust the reported timestamp. This can lead to the contract's logic being incorrect, potentially causing unexpected behavior or even allowing an attacker to exploit the contract. 
",time manipulation,3.0,491.0,6.0,2.397002696990967
130,time manipulation,"YES
 
The contract uses the `now` variable to determine if a transaction is valid. This is a common vulnerability, as the `now` variable can be manipulated by miners. 
",time manipulation,3.0,470.0,6.0,2.1431093215942383
131,time manipulation,"YES
 
The contract relies on `block.timestamp` for the `var random` calculation. This makes it vulnerable to manipulation by miners, as they can change the reported timestamp. 
",time manipulation,3.0,469.0,6.0,2.7130050659179688
132,short addresses,"YES
 
The `retrieve` function is vulnerable to a reentrancy attack.  Here's why:

* **Reentrancy:**  The `retrieve` function allows an attacker to call itself repeatedly, potentially draining the contract's funds. 
* **Uncontrolled Execution:** The `if` statement within `retrieve` allows an attacker to call the `sendCoin` function repeatedly, potentially draining the contract's funds. 
* **Potential for Exploitation:**  The `retrieve` function's logic is susceptible to reentrancy attacks, as it allows an attacker to call the `sendCoin` function repeatedly. 


",short addresses,2.0,558.0,6.0,5.064737319946289
133,denial of service,"YES
 
The contract uses a function `retrieve` that accepts a string as input and then checks if the input matches a specific hash. If it does, it transfers the balance of the contract to the sender. This function is vulnerable to a Denial of Service attack because it can be exploited to drain the contract of funds. 
",denial of service,3.0,500.0,6.0,2.8780875205993652
134,denial of service,"YES

The contract uses a function `retrieve` that accepts a string and a `msg.value` parameter. The function checks if the `msg.value` is greater than the balance of the contract minus the `msg.value`. If it is, it checks if the hash of the string passed in is equal to a specific value. If it is, the contract transfers the balance to the sender. This is a classic Denial of Service attack. 
",denial of service,3.0,524.0,6.0,3.0393295288085938
135,denial of service,"YES
 
The code has a denial of service vulnerability.  The line `creditorAddresses = new address[](0);` and `creditorAmounts = new uint[](0);`  are vulnerable to denial of service attacks. 
",denial of service,3.0,481.0,6.0,4.039057731628418
136,denial of service,"YES
 
The contract's `retrieve` function is vulnerable to a Denial of Service attack.  The `retrieve` function has a logic flaw that allows an attacker to drain the contract's funds. 
",denial of service,3.0,475.0,6.0,2.5053720474243164
137,denial of service,"YES
 
The contract uses a function `retrieve` that accepts a string `code` and then checks if the hash of the string matches a specific value. This function then transfers the balance of the contract to the sender if the hash matches. This is a classic example of a Denial of Service attack. 

The contract is vulnerable because it allows the attacker to manipulate the `code` parameter to trigger a transfer of funds. 
",denial of service,3.0,520.0,6.0,3.1939570903778076
138,denial of service,"YES

The vulnerability lies in line 23: `require(currentFrontrunner.send(currentBid));`

This line attempts to send the `currentBid` to the `currentFrontrunner` address. However, it's not a standard function call. It's a conditional statement that checks if the `currentFrontrunner` address can send the `currentBid` amount. If the `currentFrontrunner` address cannot send the `currentBid` amount, the contract will fail. 

This can be exploited by an attacker to cause a denial of service attack. 
",denial of service,3.0,552.0,6.0,3.549316644668579
