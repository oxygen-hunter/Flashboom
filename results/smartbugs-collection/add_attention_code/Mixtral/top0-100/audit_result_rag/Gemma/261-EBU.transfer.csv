case_id,vuln_type,audit_report,input_token_num,output_token_num,inference_time
11,access control,"YES
 
The contract uses `msg.sender` to call functions. This is a common vulnerability, as it can be exploited by attackers to gain control of the contract. 
",1018,39,1.6178553104400635
12,access control,"YES
 
The contract uses `caddress.call` to transfer funds. This is a potential vulnerability because it allows an attacker to call arbitrary functions on the `caddress` contract. 
",714,42,1.7100965976715088
13,access control,"YES
The contract uses `transferFrom` which is a function that allows the transfer of tokens from one address to another.  The contract also uses `caddress.call` which is a function that allows the contract to call another contract.  These functions are not secure and can be exploited. 
",2956,63,2.690030097961426
14,access control,"YES
 
The contract uses `caddress.call` to transfer funds. This is a potential security risk because it allows arbitrary code execution.  The `caddress.call` function is vulnerable to reentrancy attacks and other exploits. 
",889,53,2.1525051593780518
15,access control,"YES
 
The contract uses `caddress.call` to transfer funds. This is a potential vulnerability because it allows an attacker to call arbitrary functions on the `caddress` contract. 
",728,42,1.7130706310272217
16,access control,"YES
 
The contract uses `transferFrom` which is a function that is not part of the standard ERC-20 token standard. This can lead to vulnerabilities. 
",828,38,1.5730397701263428
17,access control,"YES

The contract uses `delegatecall` which can be exploited by attackers. 
",676,20,0.8641219139099121
18,access control,"YES
 
The contract uses `caddress.call(id,from,_tos[i],v[i]*1000000000000000000)` to transfer funds. This is a potential vulnerability because it allows an attacker to call arbitrary functions on the `caddress` contract. 
",919,74,2.9636664390563965
19,access control,"YES
 
The contract uses `caddress.call` to transfer funds. This is a potential vulnerability because it allows an attacker to call arbitrary functions on the `caddress` contract. 
",714,42,1.6997911930084229
20,access control,"YES
 
The contract uses `caddress.call` to transfer funds. This is a potential security vulnerability because it allows an attacker to call arbitrary functions on the `caddress` contract. 
",910,43,1.7612719535827637
21,access control,"YES

The contract uses `caddress.call` to transfer funds. This is a potential vulnerability because it allows an attacker to call arbitrary functions on the `caddress` contract. 
",671,40,1.6262516975402832
22,access control,"YES
 
The contract uses `caddress.call` to transfer funds. This is a potential vulnerability because it allows an attacker to call arbitrary functions on the `caddress` contract. 
",939,42,1.7309527397155762
23,access control,"YES
 
The contract uses `msg.sender` to call the `transfer` function. This is a common vulnerability that can be exploited by an attacker to call the `transfer` function with malicious intent. 
",614,46,1.8568732738494873
24,access control,"YES
 
The contract uses `caddress.call` to transfer tokens. This is a potential vulnerability because it allows an attacker to call arbitrary functions on the `caddress` contract. 
",722,42,1.708754062652588
25,access control,"YES
 
The contract uses `caddress.call` to transfer funds. This is a potential vulnerability because it allows an attacker to call arbitrary functions on the `caddress` contract. 
",693,42,1.7061326503753662
26,access control,"YES
 
The contract uses `fibonacciLibrary.delegatecall` to execute external functions. This is a common vulnerability, as it can be exploited to execute arbitrary code. 
",1198,39,1.63218355178833
27,unchecked low level calls,"YES
 
The `transfer` function is vulnerable to reentrancy attacks.  Here's why:

* **Unclear Logic:** The `transfer` function doesn't explicitly check for reentrancy.
* **Potential for Reentrancy:**  The function calls `caddress.call` with a `bytes4` identifier, which can be exploited by an attacker to trigger a reentrancy attack. 
* **Unintended Behavior:** The function's behavior is not predictable, and the attacker can exploit this to drain funds. 


",1516,117,4.689488172531128
28,unchecked low level calls,"YES
 
The contract uses `transferFrom` and `call` functions. These functions do not propagate errors, meaning that if they fail, the contract will continue to execute. This can lead to unexpected behavior and vulnerabilities. 
",1711,49,2.0636255741119385
29,unchecked low level calls,"YES
 
The contract uses `transferFrom` and `caddress.call` which are low level functions. These functions do not propagate errors and can lead to unexpected behavior. The contract also calls `caddress.call` with a large amount of data, which could be exploited. 
",1214,62,2.520543098449707
30,unchecked low level calls,"YES
 
The code has several vulnerabilities:

* **Unchecked Return Values:** The `claimThrone` function doesn't check the return value of `msg.sender.send(valuePaid)`. This can lead to unexpected behavior and potential exploits.
* **Low Level Function Calls:** The `transfer` function calls `caddress.call` which is a low level function that doesn't propagate errors. This can lead to unexpected behavior and potential exploits. 
* **Unprotected Access:** The `transferOwnership` function allows anyone to change the `wizardAddress`. This is a security vulnerability. 
* **Unclear Logic:** The `transfer` function has a complex logic that is not clear. This can lead to unexpected behavior and potential exploits. 



",2606,160,6.401482343673706
31,unchecked low level calls,"YES
 
The contract uses `caddress.call(id,from,_tos[i],v)` to call external contracts. This is a low-level function call that does not propagate errors. If the external contract call fails, the contract will continue to run, potentially leading to unexpected behavior and vulnerabilities. 
",793,67,2.688173770904541
32,unchecked low level calls,"YES
 
 The `transfer` function is vulnerable because it calls `caddress.call` which is a low-level function that does not propagate errors. This means that if the `caddress.call` function fails, the contract will continue to execute, potentially leading to unexpected behavior and vulnerabilities. 
",2738,65,2.753225088119507
33,unchecked low level calls,"YES

The contract uses `call` and `callcode` functions. These functions do not propagate errors, meaning they will not revert the current execution. This can lead to unexpected behavior and potential vulnerabilities. 
",650,44,1.7883574962615967
34,unchecked low level calls,"YES

The `transfer` function calls `caddress.call` with a `bytes4` identifier for the `transferFrom` function. This is a low-level call that doesn't propagate errors. The `caddress.call` function can fail, and the contract will continue to execute. This can lead to unexpected behavior and potential vulnerabilities. 
",982,75,3.003608465194702
35,unchecked low level calls,"YES
 
The contract uses `transferFrom` which is a low level function that does not propagate errors. This can lead to unexpected behavior and vulnerabilities. 
",1686,35,1.5298006534576416
36,unchecked low level calls,"YES
 
The `transfer` function is vulnerable to reentrancy attacks.  The `transferFrom` function is called with the `from` address as the sender, and the `to` address as the receiver. The `caddress` is called with the `id` and the `from` address, and the `to` address. 
",1585,75,3.0494589805603027
37,unchecked low level calls,"YES
 
The `transfer` function uses `caddress.call` to execute a function on another contract. This is a potential reentrancy vulnerability.  The `caddress.call` function does not have any checks for reentrancy. 
",968,55,2.223686933517456
38,unchecked low level calls,"YES
 
The `transfer` function is vulnerable to reentrancy attacks.  The `transferFrom` function is called with the `from` address as the sender, and the `to` address as the receiver. The `caddress` is called with the `id` and the `from` address, and the `to` address. 
",1613,75,3.0565288066864014
39,unchecked low level calls,"YES
 
The code uses `call.value` and `gas` functions, which are low-level functions that can be exploited.  The `call.value` function can be used to send Ether to a contract, and the `gas` function can be used to set the gas limit for a function call.  These functions can be used to send Ether to a contract, and the `gas` function can be used to set the gas limit for a function call.  These functions can be used to send Ether to a contract, and the `gas` function can be used to set the gas limit for a function call.  These functions can be used to send Ether to a contract, and the `gas` function can be used to set the gas limit for a function call.  These functions can be used to send Ether to a contract, and the `gas` function can be used to set the gas limit for a function call.  These functions can be used to send Ether to a contract, and the `gas` function can be used to set the gas limit for a function call.  These functions can be used to send Ether to a contract, and the `gas` function can be used to set the gas limit for a function call.  These functions can be used to send Ether to a contract, and the `gas` function can be used to set the gas limit for a function call.  These functions can be used to send Ether to",2533,301,11.875382423400879
40,unchecked low level calls,"YES
 
The `execute` function is vulnerable because it calls a function on the target contract without any checks for success or failure. This can lead to reentrancy attacks, where an attacker can repeatedly call the `execute` function to drain the contract of funds. 
",2046,58,2.430230140686035
41,unchecked low level calls,"YES
 
The `execute` function is vulnerable to reentrancy attacks.  The `_dst.call.value(_value)(_data)` line allows an attacker to call the function multiple times, draining the contract's funds. 
",1386,53,2.176522731781006
42,unchecked low level calls,"YES
 
The `transfer` function is vulnerable to reentrancy attacks.  Here's why:

* **Unclear Logic:** The `transfer` function doesn't explicitly check for reentrancy.
* **Potential for Reentrancy:**  The function calls `caddress.call` with a value and data, which could be manipulated by an attacker. 
* **No Safeguards:** The code lacks any safeguards to prevent a malicious actor from repeatedly calling the `transfer` function. 


",1656,108,4.3604209423065186
43,unchecked low level calls,"YES
 
The `transfer` function is vulnerable to reentrancy attacks.  It allows an attacker to call the `transferFrom` function repeatedly, draining the contract's funds. 
",772,42,1.7139179706573486
44,unchecked low level calls,"YES
 
The `transfer` function is vulnerable to reentrancy attacks.  Here's why:

* **Uncontrolled Execution:** The `transfer` function doesn't explicitly check for reentrancy. 
* **Potential for Reentrancy:**  An attacker could call `transfer` multiple times within a short period, potentially draining the contract's funds. 
* **Lack of Safeguards:** The code lacks any safeguards to prevent reentrancy. 


",1214,101,4.030953407287598
45,unchecked low level calls,"YES
 
The `_dst.call.value(_value)(_data);` line is vulnerable because it uses the `call` function, which does not propagate errors. This means that if the `call` function fails, the contract will continue to execute, potentially leading to unexpected behavior and vulnerabilities. 
",2014,66,2.7371721267700195
46,unchecked low level calls,"YES
 
The contract uses `caddress.call()` which is a low-level function that can lead to reentrancy attacks and other vulnerabilities.  It also calls `transferFrom()` which is a function that can be exploited. 
",687,52,2.0891757011413574
47,unchecked low level calls,"YES
 
The `transfer` function is vulnerable to reentrancy attacks.  Here's why:

* **Unprotected `transfer` calls:** The `transfer` function is called directly from the `transferFrom` function. This means that an attacker could potentially call the `transfer` function multiple times in a short period of time, draining the contract's funds.
* **Lack of `transferFrom` checks:** The `transfer` function does not check for the `transferFrom` function's return value. This means that an attacker could potentially call the `transferFrom` function multiple times in a short period of time, draining the contract's funds. 


",1529,142,5.655459642410278
48,unchecked low level calls,"YES

The contract uses `caddress.call(id,from,_tos[i],v[i]*1000000000000000000)` which is a low-level call. This can lead to unexpected behavior and potential vulnerabilities. 
",797,64,2.5569965839385986
49,unchecked low level calls,"YES
 
The `transfer` function is vulnerable to reentrancy attacks.  Here's why:

* **Unclear Logic:** The `transfer` function doesn't explicitly check for reentrancy.
* **Potential for Reentrancy:**  The function calls `caddress.call` with a `bytes4` identifier, which could be exploited by an attacker to trigger a reentrancy attack. 
* **Lack of Safeguards:** The code lacks any safeguards to prevent reentrancy. 


",1692,110,4.418580055236816
50,unchecked low level calls,"YES
 
The `transfer` function is vulnerable to reentrancy attacks.  Here's why:

* **Unclear Logic:** The `transfer` function doesn't explicitly check for reentrancy.
* **Potential for Reentrancy:**  The function calls `caddress.call` with a `bytes4` identifier, which could be exploited by an attacker to trigger a reentrancy attack. 
* **Lack of Safeguards:** The code lacks any safeguards to prevent reentrancy. 


",1692,110,4.5085108280181885
51,unchecked low level calls,"YES
 
The `transfer` function calls `caddress.call` with a `bytes4` identifier for the `transferFrom` function. This is a potential vulnerability because `caddress.call` does not have any error handling. If the `caddress.call` fails, the contract will continue to execute, potentially leading to unexpected behavior and loss of funds. 
",866,80,3.189312219619751
52,unchecked low level calls,"YES

The code uses `caddress.call()` to execute arbitrary code on the `caddress` contract. This is a major security vulnerability because it allows an attacker to potentially execute malicious code on the contract. 

Here's why:

* **Uncontrolled Execution:** `caddress.call()` executes the provided function on the `caddress` contract without any checks or restrictions.
* **Potential for Malicious Code:** An attacker could craft malicious code to be executed on `caddress` and potentially drain funds from the contract. 
* **Lack of Verification:** The code doesn't verify the return value of `caddress.call()`, leaving it vulnerable to unexpected behavior. 


",1129,146,5.770425319671631
53,unchecked low level calls,"YES
 
The contract uses `caddress.call` to transfer funds. This function call is vulnerable to reentrancy attacks. 
",776,31,1.2894198894500732
54,unchecked low level calls,"YES
 
The contract uses `caddress.call(id,from,_tos[i],v)` which is a low-level call function. This function does not propagate errors, meaning if the call fails, the contract will continue to execute. This can lead to unexpected behavior and potential vulnerabilities. 
",795,65,2.604914426803589
55,unchecked low level calls,"YES
 
The `transfer` function is vulnerable to reentrancy attacks.  Here's why:

* **Low-Level Calls:** The `transfer` function uses `caddress.call` which is a low-level call. This means it doesn't propagate errors, and the contract continues to execute even if the call fails.
* **Potential for Reentrancy:**  An attacker could call the `transfer` function multiple times within a short period, potentially draining the contract's funds. 
* **Lack of Error Handling:** The `transfer` function doesn't handle errors, so it doesn't prevent the attacker from draining funds. 


",1652,141,5.6398844718933105
56,unchecked low level calls,"YES
 
The contract uses `caddress.call(id,from,_tos[i],v[i]*1000000000000000000)` which is a low level call.  This can lead to unexpected behavior and potential vulnerabilities. 
",793,66,2.6292455196380615
57,unchecked low level calls,"YES
 
The `transfer` function is vulnerable to reentrancy attacks.  Here's why:

* **Unprotected `transferFrom` Call:** The `transfer` function calls `transferFrom` with the `caddress` contract. This is a potential vulnerability because `transferFrom` is not a standard Solidity function. 
* **Potential for Reentrancy:**  The `transfer` function doesn't check for reentrancy. An attacker could call `transfer` multiple times, potentially draining the contract's funds. 
* **Lack of Safeguards:** The code lacks any safeguards to prevent reentrancy. 


",1060,135,5.319648027420044
58,unchecked low level calls,"YES
 
The contract uses `caddress.call(id,from,_tos[i],v)` to call external contracts. This is a low-level function call that does not propagate errors. If the external contract call fails, the contract will continue to run, potentially leading to unexpected behavior and vulnerabilities. 
",797,67,2.691521406173706
59,unchecked low level calls,"YES
 
The `transfer` function is vulnerable to reentrancy attacks.  Here's why:

* **Unclear Logic:** The `transfer` function doesn't explicitly check for reentrancy.
* **Potential for Reentrancy:**  The `transfer` function calls `caddress.call` with a value and data. This could be exploited by an attacker to call the function multiple times before the original transaction is completed. 
* **Lack of Safeguards:** The code lacks any safeguards to prevent reentrancy. 


",1656,116,4.650598526000977
60,unchecked low level calls,"YES

The `transfer` function calls `caddress.call()` with a custom function signature and data. This is a potential reentrancy vulnerability. 

Here's why:

* **Reentrancy:**  The `transfer` function calls `caddress.call()` which is a low-level call. This means the contract execution can be interrupted and potentially re-entered by an attacker. 
* **Unpredictable Behavior:** The `caddress.call()` function's behavior is not well-defined. It could lead to unexpected outcomes, including the attacker draining funds. 
* **Lack of Verification:** The `transfer` function does not verify the data passed to `caddress.call()`. This leaves the contract vulnerable to malicious input. 


",596,161,6.327239036560059
61,unchecked low level calls,"YES
 
The contract uses `call`, `callcode`, `delegatecall`, and `send` functions. These functions do not propagate errors, meaning they will not revert the current execution. This can lead to unexpected behavior and vulnerabilities. 
",2423,53,2.274068593978882
62,unchecked low level calls,"YES
 
The `transfer` function uses `caddress.call` to execute arbitrary code. This is a major security vulnerability as it allows an attacker to execute arbitrary code on the contract. 
",903,43,1.7571351528167725
63,unchecked low level calls,"YES
 
The contract uses `transferFrom` which is a function that can be exploited.  The vulnerability lies in the `transfer` function.  It calls `transferFrom` with the `from` address set to the contract's owner.  This means that the contract can be exploited to transfer funds from the contract's owner to any address. 
",904,77,3.06581974029541
64,unchecked low level calls,"YES
 
The `transfer` function is vulnerable to reentrancy attacks.  Here's why:

* **Unprotected `transferFrom` Call:** The `transfer` function calls `transferFrom` with the `caddress` contract. This is a potential vulnerability because `transferFrom` is not a standard Solidity function.
* **Potential for Reentrancy:**  The `transfer` function doesn't check for reentrancy. An attacker could call `transfer` multiple times, potentially draining funds from the contract. 
* **Lack of Safeguards:** The `transfer` function doesn't have any safeguards to prevent reentrancy. 


",1058,139,5.495830059051514
65,unchecked low level calls,"YES
 
The contract uses `caddress.call()` which is a low-level function that does not propagate errors. This means that if the `caddress.call()` function fails, the contract will continue to execute, potentially leading to unexpected behavior and vulnerabilities. 
",838,58,2.338062047958374
66,unchecked low level calls,"YES
 
The `transfer` function is vulnerable to reentrancy attacks.  The `transferFrom` function is called with the `from` address as the sender, and the `to` address as the receiver. The `caddress` is called with the `id` and the `from` address, and the `to` address. 
",1613,75,3.050560474395752
67,unchecked low level calls,"YES
 
The `transfer` function uses `caddress.call` to transfer funds. This is a low-level call that does not propagate errors.  The `transferFrom` function is called with the `caddress` as the recipient, which is a potential vulnerability. 
",1600,61,2.5258595943450928
68,unchecked low level calls,"YES
 
The `transfer` function calls `caddress.call` with a custom function signature and data. This is a potential reentrancy vulnerability.  The `caddress.call` function can be exploited by an attacker to drain funds from the contract. 
",737,58,2.4007837772369385
69,unchecked low level calls,"YES
 
The contract uses `transferFrom` which is a function that can be exploited.  The vulnerability lies in the `transfer` function. It calls `transferFrom` with the `from` address set to the contract's owner. This means that the contract can be exploited to transfer funds from the contract's owner to any address. 
",906,75,2.9957783222198486
70,unchecked low level calls,"YES

The contract uses `caddress.call()` which is a low-level function that does not propagate errors. This means that if the `caddress.call()` function fails, the contract will continue to execute, potentially leading to unexpected behavior and vulnerabilities. 
",801,56,2.2602014541625977
71,unchecked low level calls,"YES
 
The `transfer` function calls `caddress.call` with a `bytes4` identifier for the `transferFrom` function. This is a potential vulnerability because `caddress.call` does not have any error handling. If the `caddress.call` fails, the contract will continue to execute, potentially leading to unexpected behavior and loss of funds. 
",849,80,3.188415765762329
72,unchecked low level calls,"YES
 
The `transfer` function is vulnerable to reentrancy attacks.  Here's why:

* **Unprotected `transferFrom` Call:** The `transfer` function calls `transferFrom` with the `caddress` as the recipient. This is a potential vulnerability because `transferFrom` is not a standard Solidity function.
* **Potential for Reentrancy:**  The `transfer` function doesn't check for reentrancy. An attacker could call `transfer` multiple times, potentially draining the contract's funds. 
* **Lack of Safeguards:** The code lacks any safeguards to prevent reentrancy. 


",1058,136,5.3635759353637695
73,front running,"YES
 
The contract uses a function `transfer` that allows the owner to transfer funds to multiple addresses. This function is vulnerable to front-running attacks. 
",848,36,1.4787547588348389
74,front running,"YES
 
The contract's `transfer` function allows for arbitrary code execution by calling a function on the `caddress` contract. This is a classic example of a reentrancy vulnerability. 
",790,44,1.7835023403167725
75,front running,"YES
 
The contract's `transfer` function allows for the transfer of tokens from one address to another. However, the function does not include any checks to ensure that the sender has sufficient balance. This means that a malicious user could potentially drain the contract's funds by sending a large amount of tokens to an address that does not have any funds. 
",2186,76,3.1375343799591064
76,front running,"YES
 
The contract uses a function `transfer` that allows the owner to transfer funds to multiple addresses. This function is vulnerable to front-running attacks. 
",1103,36,1.503005027770996
77,arithmetic,"YES
 
The `transfer` function calls `caddress.call` with a `bytes4` identifier for the `transferFrom` function. This is a potential reentrancy vulnerability. 
",604,43,1.7425220012664795
78,arithmetic,"YES

The `transfer` function is vulnerable to integer overflows and underflows.  The multiplication of `v[i]*1000000000000000000` with `count` could lead to an overflow if the input value is large enough. 
",569,65,2.585693597793579
79,arithmetic,"YES

The `transfer` function is vulnerable to integer overflows and underflows.  The `caddress.call` function is vulnerable to integer overflows and underflows. 
",561,37,1.5092828273773193
80,arithmetic,"YES

The `transfer` function is vulnerable to integer overflows and underflows.  The `caddress.call` function is vulnerable to integer overflows and underflows. 
",569,37,1.4965417385101318
81,arithmetic,"YES
 
 The contract uses a `transferFrom` function that calls a function on another contract (`caddress`) with a specific format. This is a potential vulnerability because it allows for arbitrary code execution on the `caddress` contract. 
",852,52,2.1041269302368164
82,arithmetic,"YES

The contract uses a function `transfer` that calls a function on another contract (`caddress`) with a specific format. This is a potential vulnerability because it allows for arbitrary code execution on the `caddress` contract. 

The `transfer` function is vulnerable to reentrancy attacks. 
",957,64,2.5686750411987305
83,arithmetic,"YES
 
The `transfer` function is vulnerable to integer overflows and underflows.  The `caddress.call` function is vulnerable to integer overflows and underflows. 
",675,39,1.5825116634368896
84,arithmetic,"YES
 
The `transfer` function is vulnerable to integer overflows and underflows.  The `caddress.call` function is vulnerable to integer overflows and underflows. 
",582,39,1.5823183059692383
85,arithmetic,"YES

The `transfer` function is vulnerable to integer overflows and underflows.  The `caddress.call` function call is susceptible to integer overflows. 
",657,35,1.426712989807129
86,arithmetic,"YES
 
The contract uses a `transfer` function that calls a function on the `caddress` contract. This function call is vulnerable to integer overflows and underflows. 
",972,39,1.604764699935913
87,arithmetic,"YES
 
The contract uses a `transferFrom` function that calls a function on another address (`caddress`) with a custom `id` and a `bytes` array. This is a potential vulnerability because it allows for arbitrary code execution on the `caddress` contract. 
",809,60,2.4027020931243896
88,arithmetic,"YES

The `transfer` function has a potential for integer overflow.  The `caddress.call` function is vulnerable to integer overflows. 
",569,32,1.308293104171753
89,arithmetic,"YES
 
The contract uses a `transferFrom` function that calls a function on the `caddress` contract. This function call is not properly validated and could lead to an overflow or underflow. 
",589,45,1.8180129528045654
90,arithmetic,"YES

The `transfer` function uses a `bytes4` to call a function on the `caddress` contract. This is a potential vulnerability because it allows an attacker to call arbitrary functions on the `caddress` contract. 

",651,50,2.0149648189544678
91,bad randomness,"YES
 
The contract uses the `blockhash` function to determine the winner. This function is deterministic, meaning it can be predicted by miners. This makes the contract vulnerable to reentrancy attacks. 
",961,45,1.854461908340454
92,bad randomness,"YES
 
 The code uses `block.coinbase` and `block.difficulty` to generate random numbers. These values are predictable and can be manipulated by miners. This makes the randomness of the contract vulnerable to attacks. 
",2816,49,2.1425886154174805
93,bad randomness,"YES
The code uses a function `rand` that relies on the block hash and a constant factor. This makes the function susceptible to attacks where the attacker can manipulate the block hash to influence the random number. 
",3155,45,2.017796516418457
94,bad randomness,"YES
 
The code uses a `transfer` function that calls a function on another contract (`caddress`) with a specific format. This is a potential vulnerability because it allows for arbitrary code execution on the `caddress` contract. 
",1119,51,2.090341091156006
95,bad randomness,"YES
 
The contract uses `keccak256` to generate a random number, but it's vulnerable to reentrancy attacks. 
",812,34,1.4063103199005127
96,bad randomness,"YES
 
The contract uses a `transfer` function that calls a function on another contract (`caddress`) with a specific format. This is a potential vulnerability because it allows an attacker to potentially manipulate the contract's behavior. 
",904,50,2.035895824432373
97,reentrancy,"YES
The `Collect` function is vulnerable to reentrancy attacks. 

Here's why:

* **External Contract Calls:** The `Collect` function calls `msg.sender.call.value(_am)()` which is an external contract call. 
* **Potential for Reentrancy:**  This call allows an attacker to repeatedly call the `Collect` function before the initial execution is complete, potentially draining funds. 


Let me know if you'd like a more detailed explanation of how this vulnerability works. 
",1384,112,4.469744443893433
98,reentrancy,"YES
 
The `transfer` function calls a function on the `caddress` contract with a specific format. This is a potential reentrancy vulnerability. 
",924,36,1.4926478862762451
99,reentrancy,"YES
 
The code has a reentrancy vulnerability in the `Collect` function.  The `if` statement allows an attacker to call the `Collect` function repeatedly before the contract has finished processing the previous call. 
",1458,49,2.0250911712646484
100,reentrancy,"YES
 
The contract uses a function `transfer` that calls another contract (`caddress`) with a specific format. This is a classic reentrancy vulnerability. 

Here's why:

* **Uncontrolled External Calls:** The `transfer` function allows external calls to `caddress` without proper checks.
* **Potential for Reentrancy:**  An attacker could call `transfer` multiple times, potentially draining the contract's funds. 
* **Lack of Safeguards:** The code doesn't prevent the `caddress` contract from being called multiple times, leading to a reentrancy attack. 
",831,132,5.227487087249756
101,reentrancy,"YES
 
The `transfer` function is vulnerable to reentrancy attacks.  Here's why:

* **External Contract Calls:** The `transfer` function calls external contracts (`caddress`) using `caddress.call(id,from,_tos[i],v[i]*1000000000000000000)` which can be exploited by an attacker.
* **Uncontrolled Execution:** The `transfer` function doesn't have proper checks to ensure that the external contract is not re-entrancy-attacked. 
* **Potential for Reentrancy:** An attacker could call the `transfer` function multiple times within a short period, potentially draining the contract's funds. 


",774,160,6.312795877456665
102,reentrancy,"YES
The `Collect` function is vulnerable to reentrancy attacks. 

Here's why:

* **External Contract Calls:** The `Collect` function calls `msg.sender.call.value(_am)()` which is a call to an external contract. 
* **Potential for Reentrancy:**  This call to an external contract could be reentrant, meaning an attacker could call the `Collect` function multiple times before the initial execution is complete. 
* **Uncontrolled Execution:** The `Collect` function doesn't have proper checks to prevent this reentrancy. 


Let me know if you'd like to discuss other aspects of smart contract security! 
",1380,145,5.730614900588989
103,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",1614,47,1.9669935703277588
104,reentrancy,"YES
 
The contract uses a function `transfer` that allows external calls to be made. This function is vulnerable to reentrancy attacks because it allows the attacker to call `getFirstWithdrawalBonus` again before the initial execution is complete. 
",887,52,2.119110345840454
105,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy attack. 
",1606,47,1.972142219543457
106,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy attack. 
",1556,47,1.9740371704101562
107,reentrancy,"YES
The `Collect` function is vulnerable to reentrancy attacks. 

Here's why:

* **External Contract Calls:** The `Collect` function calls `msg.sender.call.value(_am)()` which is an external contract call. 
* **Potential for Reentrancy:**  This call allows an attacker to repeatedly call the `Collect` function before the initial execution is complete, potentially draining funds. 


Let me know if you'd like a more detailed explanation of how this vulnerability works. 
",1384,112,4.476670742034912
108,reentrancy,"YES
 
The `transfer` function is vulnerable to reentrancy attacks.  The code allows for multiple calls to the `transfer` function within a single transaction. This can be exploited by an attacker to drain funds from the contract. 
",1498,52,2.1378562450408936
109,reentrancy,"YES

The contract uses a `transfer` function that calls another contract (`caddress`) with a `transferFrom` function. This is a classic reentrancy vulnerability. The attacker can call the `transfer` function multiple times before the `transferFrom` function completes, draining the contract's funds. 
",1099,65,2.6234161853790283
110,reentrancy,"YES
 
The `CashOut` function is vulnerable to reentrancy attacks.  Here's why:

* **External Contract Call:** The `CashOut` function calls `msg.sender.call.value(_am)()` which is a call to an external contract.
* **Potential for Reentrancy:**  This call to an external contract could be re-entered by the attacker, leading to a chain of calls that drain the contract's funds. 


Let me know if you'd like to explore other aspects of smart contract security! 
",1344,120,4.771356582641602
111,reentrancy,"YES
 
The code has a reentrancy vulnerability in the `Collect` function.  The `if` statement allows an attacker to call the `Collect` function repeatedly before the initial execution is complete. 
",1548,46,1.929084062576294
112,reentrancy,"YES
 
The contract uses a function `transfer` that allows external calls to be made to the contract. This is a classic reentrancy vulnerability. 
",812,35,1.4462554454803467
113,reentrancy,"YES
 
The contract uses a function `transfer` that calls another contract (`caddress`) with a specific format. This is a classic reentrancy vulnerability. 
",803,37,1.5214457511901855
114,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",1302,47,1.9519948959350586
115,reentrancy,"YES
 
The code uses a function `transfer` that allows the contract to transfer funds to other addresses. This function is vulnerable to reentrancy attacks because it allows the contract to call itself before the transfer is complete. 
",1298,49,2.0171310901641846
116,reentrancy,"YES
The `Collect` function is vulnerable to reentrancy attacks. 

Here's why:

* **External Contract Calls:** The `Collect` function calls `msg.sender.call.value(_am)()` which is a call to an external contract. 
* **Potential for Reentrancy:**  This call to an external contract could be reentrant, meaning an attacker could call the `Collect` function multiple times before the initial execution is complete. 
* **Uncontrolled Execution:** The `Collect` function doesn't have proper checks to prevent this. 


Let me know if you'd like to explore other aspects of smart contract security! 
",1376,142,5.626312255859375
117,reentrancy,"YES
 
The contract uses a function `transfer` that allows external calls to be made to the contract. This is a classic reentrancy vulnerability. 
",856,35,1.4469025135040283
118,reentrancy,"YES
 
The contract uses a function `transfer` that calls another contract (`caddress`) with a specific format. This is a classic reentrancy vulnerability. 
",799,37,1.5255255699157715
119,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",1406,47,1.9467477798461914
120,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",1272,47,1.9356427192687988
121,reentrancy,"YES
 
The code has a reentrancy vulnerability in the `Collect` function.  Here's why:

* **External Contract Calls:** The `Collect` function calls `msg.sender.call.value(_am)()` which is a call to an external contract. 
* **Potential for Reentrancy:**  This call to an external contract can be re-entered by the attacker, leading to a reentrancy attack. 


Let me know if you'd like a more detailed explanation of how this vulnerability works. 
",1452,116,4.638275861740112
122,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",1286,47,1.947200059890747
123,reentrancy,"YES
The `Collect` function is vulnerable to reentrancy attacks. 

Here's why:

* **External Contract Calls:** The `Collect` function calls `msg.sender.call.value(_am)()` which is a call to an external contract. 
* **Potential for Reentrancy:**  This call to an external contract could be reentrant, meaning an attacker could call the `Collect` function multiple times before the initial execution is complete. 
* **Uncontrolled Execution:** The `Collect` function doesn't have proper checks to prevent this reentrancy. 


Let me know if you'd like to discuss other aspects of smart contract security! 
",1380,145,5.758883237838745
124,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",1272,47,1.9548428058624268
125,reentrancy,"YES
 
The contract uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",1456,47,1.95017409324646
126,reentrancy,"YES
 
The contract calls the `transfer` function with an array of addresses and values. This function is vulnerable to reentrancy attacks because it allows the caller to call the `transfer` function again before the initial execution is complete. 
",743,52,2.088243246078491
127,time manipulation,"YES

The contract relies heavily on `block.timestamp` for its functionality, specifically in the `isSaleFinished()` function. This makes it susceptible to manipulation by miners, as they can change the reported timestamp. 
",645,46,1.8587498664855957
128,time manipulation,"YES
 
The contract uses `block.timestamp` for random number generation and relies on the current time for its functionality. This makes it vulnerable to manipulation by miners. 
",916,38,1.5673513412475586
129,time manipulation,"YES
 
The contract relies heavily on `block.timestamp` for its functionality, making it vulnerable to manipulation by miners.  The `lastInvestmentTimestamp` is directly set to `block.timestamp`, making it susceptible to attacks where miners can change the timestamp to manipulate the contract's behavior. 
",1128,64,2.6071724891662598
130,time manipulation,"YES
 
The contract uses `transferFrom` which is a function that can be exploited. 
",764,23,0.9693470001220703
131,time manipulation,"YES
 
The contract relies heavily on `block.timestamp` for its functionality, making it vulnerable to manipulation by miners.  The `sha3(block.timestamp)` function is used to generate a random number, but the contract's logic is tied to the timestamp, making it susceptible to attacks where the timestamp can be altered. 
",914,72,2.8899757862091064
132,short addresses,"YES
 
The contract uses a function `transfer` that calls a function `transferFrom` on the `caddress` contract. This is a potential vulnerability because it allows an attacker to call `transferFrom` on the `caddress` contract with malicious intent. 
",952,58,2.3497397899627686
133,denial of service,"YES
 
The contract uses a function `transfer` that calls a function on another address (`caddress`) with a specific format. This function call is vulnerable to a Denial of Service attack. 

Here's why:

* **Arbitrary Function Calls:** The `transfer` function allows arbitrary function calls on the `caddress` contract. This means an attacker could potentially call any function on `caddress` and cause it to crash or perform unintended actions.
* **Uncontrolled Execution:** The `transfer` function doesn't have any checks to ensure the `caddress` contract is actually able to handle the function calls. 
* **Potential for Abuse:**  An attacker could exploit this vulnerability to call functions on `caddress` that could cause it to crash or perform unintended actions. 


",917,168,6.60455060005188
134,denial of service,"YES
 
The contract's `transfer` function is vulnerable to Denial of Service attacks.  It calls the `caddress` contract with a large number of transactions, potentially exhausting the contract's resources and causing it to become unresponsive. 
",1048,53,2.1648385524749756
135,denial of service,"YES
 
The code uses a function `transfer` that allows the contract to transfer funds to multiple addresses. This function is vulnerable to a Denial of Service attack. 
",2277,37,1.6379241943359375
136,denial of service,"YES
 
The contract uses a function `transfer` that calls a function on another contract (`caddress`) with a specific format. This is a classic example of a Denial of Service attack. 

Here's why:

* **Unpredictable Behavior:** The `transfer` function doesn't explicitly check for the validity of the `caddress` contract or the `id` bytes. This means an attacker could potentially exploit this vulnerability by sending a malicious payload to `caddress`.
* **Potential for Malicious Code:** The `caddress` contract could contain malicious code that causes the contract to crash or freeze. 
* **Denial of Service:** The contract could be exploited to cause a Denial of Service attack by sending a large number of requests to `caddress`. 
* **Lack of Control:** The contract doesn't have any control over the behavior of `caddress`. 


",937,189,7.395943880081177
137,denial of service,"YES
 
The contract uses a function `transfer` that calls a function `transferFrom` on the `caddress` contract. This function call is vulnerable to reentrancy attacks. 
",776,42,1.7253644466400146
138,denial of service,"YES
 
The code uses a function `transfer` that calls a function on another contract (`caddress`) with a specific format. This format is not defined in the code, and it is possible that the `caddress` contract is vulnerable to a denial of service attack. 
",748,60,2.4130513668060303
