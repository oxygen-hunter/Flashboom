case_id,vuln_type,audit_report,input_token_num,output_token_num,inference_time
11,access control,"YES
 
The `newOwner` function allows anyone to set themselves as the owner of the contract. This is a classic access control vulnerability.  
",1034,33,1.3684241771697998
12,access control,"YES
 
The code has a potential vulnerability related to access control.  The `_transferWithRate` function has a complex logic that requires the `msg.sender` to be the owner of the contract. This can be exploited by an attacker to transfer funds from the contract to their own address. 
",730,65,2.560753107070923
13,access control,"YES
The code has a potential vulnerability related to access control. The `DynamicPyramid` function sets the creator of the contract to the `msg.sender` which is the person who calls the contract. This means anyone can call the contract and potentially change the contract's state. 
",2972,60,2.5574121475219727
14,access control,"YES
 
The code uses `_transferWithRate` function which has several vulnerabilities:

* **Unclear Transfer Rate Logic:** The code doesn't clearly define how the transfer rate is calculated. This makes it difficult to understand how the transfer fee is determined and how it affects the overall transfer process.
* **Unclear Transfer Fee Logic:** The code doesn't clearly define how the transfer fee is calculated. This makes it difficult to understand how the transfer fee is determined and how it affects the overall transfer process.
* **Unclear Allowed Logic:** The code uses `allowed` array to track transfer permissions. This array is not defined in the code, making it difficult to understand how the transfer permissions are determined.
* **Potential for Reentrancy:** The `_transferWithRate` function is susceptible to reentrancy attacks. 
* **Potential for Overflow:** The code uses `balances` and `transferFee` variables without proper checks for overflow. 
* **Potential for Underflow:** The code uses `balances` and `transferFee` variables without proper checks for underflow. 
* **Potential for Logic Errors:** The code uses `Transfer` function without proper checks for logic errors. 



",905,253,9.748963356018066
15,access control,"YES
 
The contract uses `_transferWithRate` function which has several vulnerabilities. 

* **Unclear Authorization Logic:** The function's logic is complex and unclear. It involves multiple checks and conditions, making it difficult to understand how authorization is handled.
* **Potential for Reentrancy:** The function's internal logic could be susceptible to reentrancy attacks, as it involves multiple calls to external functions.
* **Unclear Transfer Fee Calculation:** The `getTransferFee` function is not defined, making it difficult to understand how transfer fees are calculated. 
* **Potential for Overflow:** The `balances` and `allowed` arrays are not defined, making it difficult to understand how they are used and potentially leading to overflow vulnerabilities. 
* **Potential for Denial of Service:** The `withdraw` function allows the owner to withdraw funds, but it does not have any checks to prevent malicious actors from draining the contract. 



",744,197,7.631442308425903
16,access control,"YES
 
The code uses `_transferWithRate` function which has several access control vulnerabilities. 
 
* **Unclear Authorization Logic:** The function's logic is complex and unclear. It requires multiple checks and conditions, making it difficult to understand how authorization is handled.
* **Potential for Abuse:** The function allows for arbitrary transfers and fee calculations, potentially allowing attackers to manipulate the contract's state and drain funds.
* **Lack of Transparency:** The code lacks clear documentation and explanations, making it difficult to understand the intended behavior and potential vulnerabilities. 
* **Potential for Reentrancy:** The function's internal logic could be susceptible to reentrancy attacks, as it involves multiple external calls and state changes. 
* **Limited Access Control:** The `_transferWithRate` function does not explicitly define the allowed actions for different addresses. 
* **Potential for Arbitrary Code Execution:** The function's internal logic could be exploited to execute arbitrary code, potentially leading to malicious actions. 
* **Lack of Error Handling:** The code lacks proper error handling, which could lead to unexpected behavior and potential vulnerabilities. 
* **Potential for Denial of Service:** The function's logic could be exploited to cause denial of service attacks, potentially impacting the contract's functionality. 
* **Potential for Data Manipulation:** The code's internal logic could be manipulated to alter data, potentially leading to unintended consequences. 
* **",844,301,11.550846338272095
17,access control,"YES

The code uses `_transferWithRate` function which has several access control vulnerabilities. 

* **Unclear Authorization Logic:** The function requires specific conditions to be met before transferring funds, but the logic is not clear. 
* **Potential for Arbitrary Transfers:** The code allows for arbitrary transfers based on the `_from` and `_to` addresses. 
* **Unclear Transfer Fee Calculation:** The code calculates a transfer fee, but the logic is not clear. 
* **Potential for Reentrancy:** The `_transferWithRate` function could be vulnerable to reentrancy attacks. 
* **Lack of Robust Error Handling:** The code does not handle errors gracefully, which could lead to vulnerabilities. 
* **Potential for Denial of Service:** The code could be vulnerable to denial of service attacks. 



",692,175,6.7941107749938965
18,access control,"YES
 
The code uses `_transferWithRate` function which has a complex logic for transfer and fee calculation. This function is vulnerable to reentrancy attacks. 
",935,38,1.5396246910095215
19,access control,"YES
 
The code uses `_transferWithRate` function which has several vulnerabilities. 

* **Unclear Authorization Logic:** The function's logic is complex and unclear. It involves multiple checks and conditions, making it difficult to understand how authorization is handled.
* **Potential for Reentrancy:** The function's internal logic could be susceptible to reentrancy attacks, as it involves multiple calls to external functions.
* **Unclear Transfer Fee Calculation:** The code doesn't explain how the transfer fee is calculated. This could lead to unexpected behavior and potential vulnerabilities.
* **Potential for Overflow:** The code uses `balances` and `allowed` variables, which could potentially overflow if not handled correctly. 
* **Lack of Error Handling:** The code doesn't handle any errors or exceptions, which could lead to unexpected behavior and potential vulnerabilities. 
* **Potential for Denial of Service:** The code doesn't handle any limits on the number of transactions or the amount of funds that can be transferred. This could lead to a denial of service attack. 
* **Potential for Arbitrary Code Execution:** The code uses `Transfer` function, which could be exploited to execute arbitrary code. 
* **Potential for Data Manipulation:** The code doesn't handle any data validation or sanitization, which could lead to data manipulation. 
* **Potential for Privilege Escalation:** The code doesn't restrict access to certain functions, which could",730,301,11.526652574539185
20,access control,"YES
 
The code uses `_transferWithRate` function which has several vulnerabilities. 

* **Unclear Transfer Logic:** The function's logic is complex and not easily understandable. 
* **Unclear Transfer Fee Calculation:** The code doesn't explain how the transfer fee is calculated. 
* **Unclear Access Control:** The code uses `allowed` array to control access, but the logic is not clear. 
* **Potential Reentrancy:** The function could be vulnerable to reentrancy attacks. 
* **Potential Arithmetic Overflows:** The code uses `_transferWithRate` function which could be vulnerable to arithmetic overflows. 
* **Potential Logic Errors:** The code has several complex logic operations that could lead to errors. 


",926,161,6.276619911193848
21,access control,"YES

The code uses `_transferWithRate` function which has several access control vulnerabilities. 

* **Unclear Authorization Logic:** The function uses `transferAllowed` and `allowed` variables, but their definitions are not provided. This makes it difficult to understand how the authorization logic works and whether it's properly implemented.
* **Potential for Arbitrary Access:** The `_transferWithRate` function allows the contract owner to transfer funds to any address, even if the caller is not the owner. 
* **Lack of Transparency:** The code doesn't clearly define the rules for `transferAllowed` and `allowed` variables, making it difficult to understand how the contract controls access to funds. 
* **Potential for Reentrancy:** The function uses `Transfer` and `balances` variables, which could be vulnerable to reentrancy attacks. 
* **Potential for Denial of Service:** The `_transferWithRate` function could be used to drain the contract of funds by repeatedly calling it with large amounts of tokens. 



",687,216,8.36503791809082
22,access control,"YES
 
The code uses `_transferWithRate` function which has several vulnerabilities. 

* **Unclear Access Control:** The function's logic is complex and unclear. It requires specific conditions to be met before transferring funds. 
* **Potential Reentrancy:** The function's logic could be susceptible to reentrancy attacks. 
* **Unchecked Return Values:** The function's logic doesn't explicitly check the return values of the internal functions. 
* **Unclear Transfer Fee Logic:** The code doesn't explain how the transfer fee is calculated. 
* **Potential for Arbitrary Code Execution:** The function's logic allows for arbitrary code execution. 
* **Lack of Error Handling:** The code doesn't handle errors gracefully. 


",955,163,6.347022533416748
23,access control,"YES
 
The contract has a function `_transferWithRate` that allows for the transfer of funds.  The function has several vulnerabilities:

* **Unchecked Return Values:** The function returns a boolean value indicating success or failure. This can lead to vulnerabilities if the return value is not checked.
* **Access Control Issues:** The function uses `allowed[_from][msg.sender]` to check if the caller has permission to transfer funds. This is a common vulnerability that can be exploited by attackers.
* **Reentrancy Attacks:** The function has a potential for reentrancy attacks. 
* **Unclear Logic:** The logic of the function is complex and not easily understood. This can make it difficult to identify vulnerabilities. 


",630,154,5.998647928237915
24,access control,"YES
 
The contract has a potential vulnerability related to access control. The `_transferWithRate` function allows for transfers only if the caller has the required balance and if the transfer fee is paid. This is a common vulnerability, as it can be exploited by an attacker to drain the contract of funds. 
",738,66,2.6232409477233887
25,access control,"YES
 
The code uses `_transferWithRate` function which has several access control vulnerabilities. 
 
* **Unclear Authorization Logic:** The function's logic is complex and unclear. It requires multiple checks and conditions, making it difficult to understand how the authorization is determined. 
* **Unrestricted `_transferWithRate` Access:** The function is not restricted to specific addresses, allowing anyone to call it. 
* **Potential for Abuse:** The function's logic allows for arbitrary transfers and manipulation of balances, potentially leading to malicious activities. 
* **Lack of Transparency:** The code lacks clear documentation and explanations, making it difficult to understand the authorization logic and potential vulnerabilities. 
* **Potential for Reentrancy:** The function's logic could be susceptible to reentrancy attacks, as it involves multiple state changes and interactions with external contracts. 
* **Potential for Denial of Service:** The function's logic could be exploited to cause denial of service attacks, as it involves multiple state changes and interactions with external contracts. 
* **Potential for Arbitrary Code Execution:** The function's logic could be exploited to allow arbitrary code execution, as it involves multiple state changes and interactions with external contracts. 
* **Potential for Data Manipulation:** The function's logic could be exploited to manipulate data, as it involves multiple state changes and interactions with external contracts. 
* **Potential for Privilege Escalation:** The function'",709,301,11.546615362167358
26,access control,"YES
 
The contract uses `fibonacciLibrary.delegatecall` to execute external functions. This is a common vulnerability, as it can be exploited to execute arbitrary code. 
",1214,39,1.6137478351593018
27,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable to reentrancy attacks.  Here's why:

* **Low-Level Calls:** The `_transferWithRate` function uses `adr.call.value(msg.value)(data)` which is a low-level call. This means the contract doesn't handle the return value of the call, and the execution continues.
* **Reentrancy Vulnerability:**  An attacker could call `_transferWithRate` multiple times in a short period, potentially draining the contract's funds. 
* **Lack of Safeguards:** The function doesn't include any safeguards to prevent reentrancy. 


Let me know if you'd like to explore other aspects of smart contract security! 
",1532,163,6.382756948471069
28,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable to reentrancy attacks.  The function does not handle reentrancy attacks properly. 
",1727,35,1.4868156909942627
29,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable to reentrancy attacks.  Here's why:

* **Low-Level Calls:** The `_transferWithRate` function uses `adr.call.value(msg.value)(data)` which is a low-level call. This means the contract doesn't handle errors in the same way as other functions.
* **Potential for Reentrancy:**  An attacker could call `_transferWithRate` multiple times in rapid succession, potentially draining the contract's funds. 
* **Lack of Error Handling:** The function doesn't explicitly check for reentrancy, making it susceptible to attacks. 


Let me know if you'd like to explore other aspects of smart contract security! 
",1230,164,6.373693227767944
30,unchecked low level calls,"YES
 
The code has several vulnerabilities:

* **Unchecked Return Values:** The `_transferWithRate` function does not check the return value of `_transferWithRate`. This can lead to unexpected behavior and potential vulnerabilities.
* **Low Level Function Calls:** The `_transferWithRate` function uses low-level functions like `send` and `call`. These functions can be tricky to debug and can lead to unexpected behavior. 
* **Unprotected Access:** The `transferOwnership` function allows anyone to change the contract's owner. This is a major security vulnerability. 
* **Reentrancy:** The `claimThrone` function is vulnerable to reentrancy attacks. 
* **Arithmetic Overflows and Underflows:** The code does not handle arithmetic overflows and underflows well. 
* **Timestamp Dependence:** The `claimThrone` function uses the block timestamp for critical functionality. This can be manipulated by miners. 



",2622,200,7.877639532089233
31,unchecked low level calls,"YES

The `_transferWithRate` function uses `caddress.call` to transfer tokens. This is a low-level call that doesn't propagate errors.  The function doesn't check if the `caddress` is valid or if the transfer is allowed. This can lead to a reentrancy attack or other vulnerabilities. 
",809,73,2.8812637329101562
32,unchecked low level calls,"YES
 
 The `_transferWithRate` function is vulnerable because it uses `call`, `callcode`, `delegatecall`, and `send` functions. These functions do not propagate errors, meaning that if they fail, the code will continue to run. This can lead to unexpected behavior and potential vulnerabilities. 
",2754,68,2.8308334350585938
33,unchecked low level calls,"YES

The contract uses `_transferWithRate` function which has several potential vulnerabilities.  

* **Unchecked Return Values:** The `_transferWithRate` function returns `true` without checking the success of the transfer. This can lead to unexpected behavior and potential exploits.
* **Low Level Calls:** The `_transferWithRate` function uses `callee.call()` and `Transfer` which are low-level calls. These calls can be exploited by attackers to drain the contract of funds. 
* **Unclear Logic:** The logic within `_transferWithRate` is complex and not well-documented. This makes it difficult to understand the contract's behavior and identify potential vulnerabilities. 
* **Access Control:** The contract uses `allowed` array to control access to functions. However, the logic for setting and checking `allowed` is not clear. 


",666,181,6.9788525104522705
34,unchecked low level calls,"YES

The code uses `_transferWithRate` function which has several vulnerabilities. 

* **Unchecked Return Values:** The `_transferWithRate` function returns a boolean value, but it doesn't check the return value. This can lead to unexpected behavior and potential vulnerabilities.
* **Low Level Function Calls:** The `_transferWithRate` function calls `transferFrom` with `msg.sender` as the sender. This can be exploited by an attacker to drain funds from the contract.
* **Unclear Logic:** The code has complex logic with multiple checks and conditions. This makes it difficult to understand the intended behavior and identify potential vulnerabilities. 
* **Unclear Transfer Fee Calculation:** The code calculates a transfer fee, but the logic for calculating the fee is not clear. This can lead to unexpected behavior and potential vulnerabilities. 
* **Unclear Fee Receivers:** The code uses `feeReceAccount` but doesn't explain how it's used. This can lead to unexpected behavior and potential vulnerabilities. 


",998,215,8.356176853179932
35,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable to reentrancy attacks.  Here's why:

* **Low-Level Calls:** The `_transferWithRate` function uses `adr.call.value(msg.value)(data)` which is a low-level call. This means the contract doesn't handle errors in the same way as other functions.
* **Potential for Reentrancy:**  An attacker could call `_transferWithRate` multiple times in a short period, potentially draining the contract's funds. 
* **Lack of Error Handling:** The function doesn't explicitly check for reentrancy, making it susceptible to attacks. 


",1702,146,5.739237308502197
36,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable to reentrancy attacks.  Here's why:

* **Unprotected External Calls:** The `_transferWithRate` function calls external functions (`Transfer`, `getTransferFee`, `allowed`) without proper checks. 
* **Potential for Reentrancy:** An attacker could call `_transferWithRate` multiple times in rapid succession, potentially draining funds from the contract. 
* **Lack of Safeguards:** The function doesn't include any safeguards to prevent reentrancy, making it susceptible to attacks. 


",1601,125,4.909890174865723
37,unchecked low level calls,"YES

The code uses `_transferWithRate` function which has several vulnerabilities. 

* **Unchecked Return Values:** The `_transferWithRate` function returns a boolean value, but it doesn't check the return value. This can lead to unexpected behavior and potential vulnerabilities.
* **Low Level Function Calls:** The `_transferWithRate` function uses low-level functions like `call`, `callcode`, `delegatecall`, and `send`. These functions don't propagate errors, so if they fail, the contract might continue to execute without proper error handling.
* **Unclear Access Control:** The `_transferWithRate` function has access control logic, but it's not clear how it's implemented. This can lead to vulnerabilities if the access control logic is not properly implemented. 
* **Potential Reentrancy:** The `transfer` function calls `_transferWithRate` which could be vulnerable to reentrancy attacks. 


",984,202,7.805178880691528
38,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable because it calls `transfer` with a `bytes4` value. This can lead to reentrancy attacks, as the attacker can call the function multiple times to drain the contract's funds. 
",1629,57,2.3215625286102295
39,unchecked low level calls,"YES
 
The code uses `call.value` and `gas` functions, which are low-level functions that can be exploited.  The `call.value` function can be used to send a value to an address, and the `gas` function can be used to set the gas limit for the transaction.  These functions can be used to send a large amount of gas to an address, which can be used to drain the contract of funds. 
",2549,97,3.9203245639801025
40,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable because it does not handle the case where the transfer fails.  The function does not propagate errors, and the code will continue to run. This can lead to unexpected outcomes and security vulnerabilities. 
",2062,55,2.2781081199645996
41,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable because it uses the `_dst.call.value(_value)(_data)` function. This function does not propagate errors, meaning that if the call fails, the contract will continue to execute. This can lead to unexpected behavior and potential vulnerabilities. 
",1402,67,2.6773195266723633
42,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable to reentrancy attacks.  Here's why:

* **Low-Level Calls:** The `_transferWithRate` function uses `adr.call.value(msg.value)(data)` which is a low-level call. This means the contract doesn't handle the return value of the call.
* **Potential for Reentrancy:**  An attacker could call `_transferWithRate` multiple times in a loop, potentially draining the contract's funds. 
* **No Error Handling:** The function doesn't check for errors or handle them appropriately. 


",1672,137,5.386577606201172
43,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable to reentrancy attacks.  It allows for multiple calls to `_transferWithRate` without proper checks, which can lead to an attacker draining the contract's funds. 
",788,53,2.1097218990325928
44,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable to reentrancy attacks.  Here's why:

* **Low-Level Calls:** The `_transferWithRate` function uses `adr.call.value(msg.value)(data)` which is a low-level call. This means the contract doesn't handle errors in the same way as other functions.
* **Potential for Reentrancy:**  An attacker could call `_transferWithRate` multiple times in rapid succession, potentially draining the contract's funds. 
* **Lack of Error Handling:** The function doesn't explicitly check for reentrancy, making it susceptible to attacks. 


Let me know if you'd like to explore other aspects of smart contract security! 
",1230,164,6.405956268310547
45,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable to reentrancy attacks.  Here's why:

* **Low-Level Calls:** The `_transferWithRate` function uses `_dst.call.value(_value)(_data)` which is a low-level call. This means the contract doesn't have a way to handle the potential for reentrancy.
* **Potential for Reentrancy:**  An attacker could call `_transferWithRate` multiple times in rapid succession, potentially draining funds from the contract. 
* **Lack of Safeguards:** The code lacks any checks to prevent reentrancy. 


",2030,139,5.519871234893799
46,unchecked low level calls,"YES

The `_transferWithRate` function is vulnerable to reentrancy attacks. It allows for multiple calls to `_transferWithRate` within a single transaction, potentially leading to a loss of funds. 
",703,46,1.8297393321990967
47,unchecked low level calls,"YES
 
The `WithdrawToken` function calls the `token.call` function. This function is vulnerable because it does not handle errors. If the `token.call` function fails, the contract will continue to execute, potentially leading to unexpected behavior and vulnerabilities. 
",1545,58,2.3607513904571533
48,unchecked low level calls,"YES

The code uses `caddress.call(id,from,_tos[i],v[i])` which is a low-level call function. This function does not propagate errors, meaning if it fails, the contract will continue to execute. This can lead to unexpected behavior and potential vulnerabilities. 
",813,65,2.5628578662872314
49,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable because it uses the `call`, `callcode`, `delegatecall`, and `send` functions. These functions do not propagate errors, meaning that if the function call fails, the contract will continue to execute. This can lead to unexpected behavior and potential vulnerabilities. 
",1708,71,2.881010055541992
50,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable because it uses the `call`, `callcode`, `delegatecall`, and `send` functions. These functions do not propagate errors, meaning that if the function call fails, the contract will continue to execute. This can lead to unexpected behavior and potential vulnerabilities. 
",1708,71,2.877046823501587
51,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable to reentrancy attacks.  It allows for multiple calls to the same function, potentially leading to a loss of funds. 
",882,42,1.6891798973083496
52,unchecked low level calls,"YES

The code uses `caddress.call()` which is a low-level function that doesn't propagate errors. This means that if the call fails, the contract will continue to execute, potentially leading to unexpected behavior and vulnerabilities. 
",1145,51,2.060349702835083
53,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable to reentrancy attacks.  It allows for multiple calls to the `_transferWithRate` function without proper checks. 
",792,42,1.6793427467346191
54,unchecked low level calls,"YES

The code uses `caddress.call(id,from,_tos[i],v)` which is a low-level call function.  This function does not propagate errors, meaning if it fails, the contract will continue to execute. This can lead to unexpected behavior and potential vulnerabilities. 
",811,63,2.4915802478790283
55,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable to reentrancy attacks.  Here's why:

* **Low-Level Calls:** The `_transferWithRate` function uses `adr.call.value(msg.value)(data)` which is a low-level call. This means the contract doesn't handle the return value of the call.
* **Potential for Reentrancy:**  An attacker could call `_transferWithRate` multiple times in a loop, potentially draining the contract's funds. 
* **Lack of Error Handling:** The function doesn't check for the success of the `call` operation. 


",1668,141,5.563408613204956
56,unchecked low level calls,"YES
 
The contract uses `_transferWithRate` function which has several vulnerabilities. 
* **Unchecked Return Values:** The function returns a boolean value, but it doesn't check the return value. This can lead to unexpected behavior.
* **Low Level Function Calls:** The `fuck.call` function is a low-level call that doesn't propagate errors. This can lead to unexpected behavior and potential vulnerabilities. 
* **Access Control Vulnerabilities:** The `_transferWithRate` function has access control vulnerabilities. 
* **Reentrancy Attacks:** The function is vulnerable to reentrancy attacks. 
* **Arithmetic Overflows and Underflows:** The function performs arithmetic operations that could lead to overflows and underflows. 
* **Unchecked Return Values:** The function returns a boolean value, but it doesn't check the return value. This can lead to unexpected behavior. 
* **Unclear Logic:** The logic of the `_transferWithRate` function is unclear and could be vulnerable to exploits. 



",809,219,8.495585203170776
57,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable to reentrancy attacks.  Here's why:

* **Unclear State:** The function doesn't explicitly check for reentrancy. 
* **Potential for Reentrancy:**  The function allows for multiple calls to be made within a single transaction. 
* **Unintended Behavior:**  The function's logic could be manipulated to allow an attacker to repeatedly call the function and drain the contract of funds. 


",1076,106,4.14393424987793
58,unchecked low level calls,"YES

The `_transferWithRate` function uses `caddress.call` to transfer tokens. This is a low-level call that doesn't propagate errors.  The function doesn't check if the `caddress` is valid or if the transfer is successful. This can lead to a denial-of-service attack or a loss of funds. 
",813,77,3.0437123775482178
59,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable to reentrancy attacks.  Here's why:

* **Low-Level Calls:** The `_transferWithRate` function uses `adr.call.value(msg.value)(data)` which is a low-level call. This means the contract doesn't handle the return value of the call.
* **Potential for Reentrancy:**  An attacker could call `_transferWithRate` multiple times in a loop, potentially draining the contract's funds. 
* **No Error Handling:** The function doesn't check for errors or handle them appropriately. 


",1672,137,5.388608694076538
60,unchecked low level calls,"YES

The code uses the `_transferWithRate` function which has several potential vulnerabilities. 

* **Unchecked Return Values:** The `_transferWithRate` function returns a boolean value, but it doesn't explicitly check the return value. This can lead to unexpected behavior and potential vulnerabilities.
* **Low Level Calls:** The `_transferWithRate` function uses `a.call()`, which is a low-level call. This can lead to unexpected behavior and potential vulnerabilities.
* **Unclear Transfer Logic:** The code doesn't clearly define how the transfer fee is calculated or how it interacts with the balance of the `feeReceAccount`. This can lead to unexpected behavior and potential vulnerabilities. 
* **Potential Reentrancy:** The `callAddress` function is vulnerable to reentrancy attacks. 


",612,172,6.627897500991821
61,unchecked low level calls,"YES
 
The code uses `callFirstTarget` and `callSecondTarget` functions. These functions call external contracts without any checks for success or failure. This can lead to reentrancy attacks, where an attacker can repeatedly call the function and drain the contract of funds. 
",2439,60,2.491954803466797
62,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable to reentrancy attacks.  Here's why:

* **Uncontrolled Execution:** The `_transferWithRate` function allows for multiple calls within a single transaction. 
* **Potential for Reentrancy:**  An attacker could call `_transferWithRate` multiple times within a single transaction, potentially draining the contract's funds. 
* **Lack of Safeguards:** The function doesn't include any safeguards to prevent reentrancy. 


Let me know if you'd like to explore other aspects of smart contract security! 
",919,131,5.089171886444092
63,unchecked low level calls,"YES

The `_transferWithRate` function has several vulnerabilities:

* **Unchecked Return Values:** The function returns `true` without checking for errors. This can lead to unexpected behavior and potential vulnerabilities.
* **Unclear Logic:** The function's logic is complex and not easily understandable. This makes it difficult to identify potential vulnerabilities.
* **Potential for Reentrancy:** The function allows for external contract calls, which could be exploited by a malicious actor. 
* **Unclear Transfer Fee Calculation:** The `getTransferFee` function is not defined, making it difficult to assess the potential for vulnerabilities. 
* **Potential for Overflow:** The `balances` array is not defined, making it difficult to assess the potential for overflows. 
* **Potential for Denial of Service:** The function allows for external contract calls, which could be exploited by a malicious actor. 



",920,184,7.150636196136475
64,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable to reentrancy attacks.  Here's why:

* **Unclear State:** The function doesn't explicitly check for reentrancy. 
* **Potential for Reentrancy:**  The function allows for multiple calls to be made within a single transaction. 
* **Unintended Behavior:**  The function's logic could be manipulated to allow an attacker to repeatedly call the function and drain the contract of funds. 


",1074,106,4.163132905960083
65,unchecked low level calls,"YES

The code uses `caddress.call(id,from,_tos[i],_value);` which is a low-level call function. This function does not propagate errors, meaning that if it fails, the contract will continue to execute. This can lead to unexpected behavior and potential vulnerabilities. 
",854,65,2.5905585289001465
66,unchecked low level calls,"YES
 
The `WithdrawToken` function calls the `token.call` function, which is a low-level function that does not propagate errors. This means that if the `token.call` function fails, the contract will not revert. This can lead to a loss of funds for the contract owner. 
",1629,67,2.698289632797241
67,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable to reentrancy attacks.  Here's why:

* **Low-Level Calls:** The `_transferWithRate` function uses `adr.call.value(msg.value)(data)` which is a low-level call. This means the contract doesn't handle the return value of the call, and the execution continues.
* **Potential for Reentrancy:**  An attacker could call `_transferWithRate` multiple times in a short period, potentially draining the contract's funds. 
* **Lack of Safeguards:** The code doesn't include any safeguards to prevent reentrancy. 


",1616,145,5.689143657684326
68,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable to reentrancy attacks.  It allows for multiple calls to the function without proper checks, which can lead to an attacker draining the contract of funds. 
",753,48,1.9147846698760986
69,unchecked low level calls,"YES

The `_transferWithRate` function has several vulnerabilities:

* **Unchecked Return Values:** The function returns `true` without checking for errors. This can lead to unexpected behavior and potential vulnerabilities.
* **Unclear Logic:** The function's logic is complex and not easily understandable. This makes it difficult to identify potential vulnerabilities.
* **Potential Reentrancy:** The function allows for external contract calls, which could be exploited for reentrancy attacks. 
* **Unclear Transfer Fee Calculation:** The `getTransferFee` function is not defined, making it difficult to assess the potential for vulnerabilities. 
* **Unclear Balance Management:** The function manipulates balances in a way that is not immediately clear, potentially leading to unexpected outcomes. 


",922,159,6.159839630126953
70,unchecked low level calls,"YES

The code uses `caddress.call(id,from,_tos[i],v[i])` which is a low-level call function. This function does not propagate errors, meaning that if the call fails, the contract will continue to execute. This can lead to unexpected behavior and potential vulnerabilities. 
",817,67,2.650796890258789
71,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable to reentrancy attacks.  It allows for multiple calls to the same function, potentially draining the contract of funds. 
",865,41,1.6583595275878906
72,unchecked low level calls,"YES
 
The `_transferWithRate` function is vulnerable to reentrancy attacks.  Here's why:

* **Unclear State:** The function doesn't explicitly check for reentrancy. 
* **Potential for Reentrancy:**  The function allows for multiple calls to be made within a single transaction. 
* **Unintended Behavior:**  The function's logic could be manipulated to allow an attacker to repeatedly call the function and drain the contract of funds. 


",1074,106,4.172799825668335
73,front running,"YES

The code uses a complex internal function `_transferWithRate` that involves multiple checks and balances. This function is vulnerable to front-running attacks. 

Here's why:

* **Complex Logic:** The function has multiple conditions and checks, making it difficult to understand the flow and potential vulnerabilities.
* **Transfer Fee:** The code includes a transfer fee calculation, which could be exploited by malicious actors.
* **Transfer Rate:** The code uses a transfer rate, which could be manipulated to allow for front-running attacks. 
* **Transfer Fee to Owner:** The code includes a transfer fee to the owner, which could be exploited by malicious actors. 
* **Transfer to Fee Receivers:** The code includes a transfer to a fee receiver, which could be exploited by malicious actors. 


",864,169,6.580479860305786
74,front running,"YES
 
The contract's `_transferWithRate` function has several vulnerabilities that could be exploited for front-running attacks.  Here's why:

* **Unclear Transfer Rate:** The contract doesn't specify how the transfer rate is determined. This could be manipulated by malicious actors to their advantage.
* **Transfer Fee Calculation:** The `getTransferFee` function is not defined, making it impossible to assess the potential for manipulation.
* **Insufficient Balance Checks:** The contract doesn't adequately check if the sender has sufficient funds to cover the transfer fee and the actual value of the transfer.
* **Unclear Allowed Balance:** The `allowed` array is not defined, making it impossible to assess the potential for manipulation. 
* **Potential for Manipulation:** The contract's logic allows for manipulation of the transfer fee and the actual value of the transfer. 


",806,185,7.176255941390991
75,front running,"YES
 
The contract uses a transfer function that allows for the transfer of tokens.  The function has a transfer fee that is added to the transfer amount.  This can be exploited by a malicious user to drain the contract of funds. 
",2202,52,2.18044114112854
76,front running,"YES
 
The code uses a function `_transferWithRate` that allows for transfers with a specified rate and fee. This function has several vulnerabilities:

* **Reentrancy:** The function `_transferWithRate` could be vulnerable to reentrancy attacks. 
* **Unchecked Return Values:** The function `_transferWithRate` does not check the return value of the `Transfer` function. 
* **Unclear Logic:** The logic of the `_transferWithRate` function is not clear and could be vulnerable to exploits. 
* **Potential for Abuse:** The function `_transferWithRate` could be abused to drain funds from the contract. 


",1119,143,5.571682929992676
77,arithmetic,"YES

The `_transferWithRate` function uses unsigned integers and performs arithmetic operations without proper checks for overflows. This can lead to unexpected behavior and potential vulnerabilities. 
",620,36,1.4458963871002197
78,arithmetic,"YES

The `_transferWithRate` function performs arithmetic operations on unsigned integers, which can lead to integer overflows and underflows. 
",585,30,1.2210469245910645
79,arithmetic,"YES

The code uses unsigned integers and lacks proper checks for overflows.  The `_transferWithRate` function, in particular, has a high risk of integer overflows. 
",577,38,1.5275485515594482
80,arithmetic,"YES

The code uses unsigned integers and has a function that subtracts a value from a variable. This can lead to arithmetic overflows and underflows, especially if the input value is large. 
",585,41,1.6356282234191895
81,arithmetic,"YES
 
 The code uses a complex transfer logic with multiple checks and conditions.  The `_transferWithRate` function is particularly vulnerable to integer overflows and underflows.  The `_transferWithRate` function is designed to transfer funds, but it also includes a complex set of checks and conditions that could lead to unexpected behavior and potential vulnerabilities. 
",868,75,2.9645402431488037
82,arithmetic,"YES

The code has potential for integer overflows and underflows.  The `_transferWithRate` function is particularly vulnerable. 
",973,29,1.1949787139892578
83,arithmetic,"YES

The code uses unsigned integers and has a function that subtracts a value from a variable. This can lead to integer overflows, especially if the input value is large. 
",691,38,1.527791976928711
84,arithmetic,"YES

The code uses unsigned integers and has a potential for integer overflows.  The line `uint res = count - input;` could lead to an overflow if the `input` value is large enough. 
",598,45,1.7839477062225342
85,arithmetic,"YES

The `_transferWithRate` function is vulnerable to integer overflows and underflows.  The line `require(balances[_to] + _value > balances[_to]);`  can lead to overflows if the `_value` is large enough. 
",673,56,2.2101521492004395
86,arithmetic,"YES
 
The code uses unsigned integers and has functions that perform arithmetic operations.  The code is vulnerable to integer overflows and underflows. 
",988,32,1.3136343955993652
87,arithmetic,"YES

The code uses a complex transfer function with multiple checks and conditions.  The `_transferWithRate` function introduces potential vulnerabilities:

* **Unclear Transfer Rate:** The code doesn't clearly define what the ""transfer rate"" is. This could be a malicious parameter that allows for arbitrary manipulation of the transfer process.
* **Transfer Fee Calculation:** The `getTransferFee` function is not defined. This makes it difficult to understand how the transfer fee is calculated, potentially leading to unexpected behavior.
* **Insufficient Balance Checks:** The code checks for sufficient balance before transferring tokens, but it doesn't explicitly check for the transfer fee. This could lead to a situation where the contract attempts to transfer more tokens than it actually has.
* **Unclear Allowed Status:** The code checks for allowed status, but it's unclear how this is determined. This could lead to unexpected behavior if the allowed status is not properly managed.
* **Potential for Overflow:** The code uses unsigned integers for balances and transfer fees, which can lead to overflows if not handled carefully.


",825,222,8.594091892242432
88,arithmetic,"YES

The `_transferWithRate` function has a potential for integer overflow.  It performs arithmetic operations on unsigned integers, and the `count += input` line could lead to an overflow if the input value is too large. 
",585,50,1.9844610691070557
89,arithmetic,"YES

The code has a potential for integer overflows and underflows.  The line `sellerBalance += value;`  is susceptible to overflow, especially if the `value` is large. 
",605,42,1.6792502403259277
90,arithmetic,"YES

The code has a potential for integer overflows and underflows.  The line `balances[_to] += _value;`  is particularly vulnerable. 
",667,35,1.409907341003418
91,bad randomness,"YES
 
The contract uses the `blockhash` function, which is deterministic and predictable. This means that an attacker could potentially calculate the hash of a block and then use that to manipulate the contract's behavior. 
",977,48,1.9226574897766113
92,bad randomness,"YES
 
The code uses `block.number` to generate random numbers for the raffle. This is a bad practice because `block.number` is predictable and can be manipulated by miners. 
",2832,43,1.8754808902740479
93,bad randomness,"YES
The code uses a function `_transferWithRate` that has a complex logic for transfer fees and transfer rates. This function is vulnerable to reentrancy attacks. 
",3171,38,1.711477518081665
94,bad randomness,"YES
 
 The code uses a function `_transferWithRate` that has a complex logic for transfer and fee management. This function is vulnerable to reentrancy attacks. 
 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
",1135,301,11.645510911941528
95,bad randomness,"YES
 
The contract uses `keccak256` to generate a random number, but it's vulnerable to predictable attacks. The `block.blockhash` and `block.number` values are directly tied to the blockchain's state, making the generated number predictable. 
",828,62,2.447582960128784
96,bad randomness,"YES
 
The code uses a predictable random number generator. The `random` function relies on the `salt` variable, which is directly tied to the block timestamp. This makes the generated numbers predictable and susceptible to manipulation by attackers. 
",920,51,2.040466785430908
97,reentrancy,"YES
The `Collect` function is vulnerable to reentrancy attacks. 

Here's why:

* **External Contract Calls:** The `Collect` function calls `msg.sender.call.value(_am)()` which is a call to an external contract. 
* **Potential for Reentrancy:**  This call to an external contract could be re-entered by the attacker, leading to a chain of calls that drain the contract's funds. 


Let me know if you'd like a more detailed explanation of how this vulnerability works. 
",1400,119,4.684732437133789
98,reentrancy,"YES
 
The code uses a function `_transferWithRate` that allows for transfers with a transfer fee and a transfer rate. This function is vulnerable to reentrancy attacks. 
",940,41,1.6468331813812256
99,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy attack. 
",1474,47,1.913008689880371
100,reentrancy,"YES

The code uses a function `_transferWithRate` that allows for transfers with a transfer fee and a transfer rate. This function is vulnerable to reentrancy attacks because it allows for external contract calls to be made before the initial execution is complete. 
",847,55,2.190122127532959
101,reentrancy,"YES
 
The `_transferWithRate` function is vulnerable to reentrancy attacks.  Here's why:

* **External Contract Calls:** The function calls `msg.sender.call.value(amount)`, which allows an attacker to potentially call the contract again before the initial execution is complete. 
* **Potential for Reentrancy:**  This creates a window for an attacker to call the contract again and again, draining funds. 


Let me know if you'd like a more detailed explanation of how this vulnerability works. 
",790,117,4.566643476486206
102,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy attack. 
",1396,47,1.9190833568572998
103,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy attack. 
",1630,47,1.9399926662445068
104,reentrancy,"YES
 
The contract's `_transferWithRate` function allows for reentrancy attacks.  The function calls `Transfer` which can be exploited by an attacker to drain funds. 
",903,43,1.732966661453247
105,reentrancy,"YES
 
The `Collect` function is vulnerable to reentrancy attacks.  Here's why:

* **External Contract Calls:** The `Collect` function calls `msg.sender.call.value(_am)()` which is a call to an external contract. This means the contract can potentially execute code before the initial execution is complete.
* **Reentrancy Vulnerability:**  The `Collect` function is susceptible to reentrancy because it allows an attacker to repeatedly call the function and drain the contract of funds. 


Let me know if you'd like to explore other aspects of smart contract security! 
",1622,131,5.123207330703735
106,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",1572,47,1.937941312789917
107,reentrancy,"YES
The `Collect` function is vulnerable to reentrancy attacks. 

Here's why:

* **External Contract Calls:** The `Collect` function calls `msg.sender.call.value(_am)()` which is a call to an external contract. 
* **Potential for Reentrancy:**  This call to an external contract could be re-entered by the attacker, leading to a re-entrancy attack. 
* **Uncontrolled Execution:** The `Collect` function doesn't have proper checks to prevent the attacker from repeatedly calling the function. 


Let me know if you'd like to discuss other aspects of smart contract security! 
",1400,142,5.5718889236450195
108,reentrancy,"YES
 
The `_transferWithRate` function is vulnerable to reentrancy attacks.  Here's why:

* **External Contract Calls:** The function calls external contracts (`token.call`) without proper checks.
* **Potential for Reentrancy:**  An attacker could call the `_transferWithRate` function multiple times within a short period, potentially draining the contract's funds. 
* **Lack of Safeguards:** The function doesn't include any safeguards to prevent reentrancy. 


",1514,110,4.36429500579834
109,reentrancy,"YES
 
The contract uses a `supportsToken` function that calls `airDrop` from the `ModifierEntrancy` contract. This creates a reentrancy vulnerability because the `airDrop` function can be called repeatedly before the initial execution is complete. 
",1115,56,2.2548773288726807
110,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",1360,47,1.912383794784546
111,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",1564,47,1.9357094764709473
112,reentrancy,"YES
 
The `_transferWithRate` function is vulnerable to reentrancy attacks.  Here's why:

* **External Contract Calls:** The function allows external contract calls (`msg.sender.call.value(oCredit)`) within its own execution.
* **Potential for Reentrancy:**  An attacker could call the `_transferWithRate` function multiple times within a short period, potentially draining the contract's funds. 
* **Lack of Safeguards:** The function doesn't include any safeguards to prevent repeated calls or handle the potential for reentrancy. 


",828,127,4.935292720794678
113,reentrancy,"YES
 
The code uses a function `_transferWithRate` that has a potential reentrancy vulnerability.  Here's why:

* **External Contract Calls:** The function `_transferWithRate` allows external contracts to call functions within the `EtherBank` contract.
* **Potential for Reentrancy:**  An attacker could call `_transferWithRate` multiple times within a short period, potentially draining the contract's funds. 
* **Lack of Safeguards:** The code doesn't include any safeguards to prevent reentrancy, making it vulnerable to this attack. 


",819,127,4.968781471252441
114,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",1318,47,1.9148144721984863
115,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",1314,47,1.9047088623046875
116,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy attack. 
",1392,47,1.9195268154144287
117,reentrancy,"YES
 
The contract uses a function `_transferWithRate` that allows for external calls to be made to the contract. This is a classic reentrancy vulnerability. 
",872,39,1.5781164169311523
118,reentrancy,"YES
 
The code implements a function `_transferWithRate` that allows for transfers with a transfer fee and a transfer rate. This function has several vulnerabilities:

* **Reentrancy:** The function `_transferWithRate` allows for external calls to be made before the initial execution is complete. This can be exploited by an attacker to drain the contract of funds.
* **Unchecked Return Values:** The function `_transferWithRate` does not check the return value of the external call. This can lead to vulnerabilities.
* **Access Control:** The function `_transferWithRate` does not have proper access control. This can lead to vulnerabilities. 
* **Unclear Logic:** The logic of the function is not clear and can be exploited by an attacker. 


",815,163,6.32858943939209
119,reentrancy,"YES
 
The code has a reentrancy vulnerability in the `CashOut` function.  The `if(msg.sender.call.value(_am)())` line allows an attacker to call the `CashOut` function repeatedly before the initial execution is complete. 
",1422,60,2.4174184799194336
120,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",1288,47,1.9183766841888428
121,reentrancy,"YES
 
The code has a reentrancy vulnerability in the `Collect` function.  The `if` statement allows an attacker to call the `Collect` function repeatedly before the contract has resolved the effects of the previous call. 
",1468,51,2.0722062587738037
122,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",1302,47,1.9041712284088135
123,reentrancy,"YES
The `Collect` function is vulnerable to reentrancy attacks. 

Here's why:

* **External Contract Calls:** The `Collect` function calls `msg.sender.call.value(_am)()` which is a call to an external contract. 
* **Potential for Reentrancy:**  This call to an external contract could be re-entered by the attacker, leading to a re-entrancy attack. 
* **Uncontrolled Execution:** The `Collect` function doesn't have proper checks to prevent the attacker from repeatedly calling the function. 


Let me know if you'd like a more detailed explanation of how a reentrancy attack could work in this specific scenario. 
",1396,151,5.873062610626221
124,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",1288,47,1.9102733135223389
125,reentrancy,"YES
 
The code uses `msg.sender.call.value(_am)()` which allows an attacker to call the contract again before the initial execution is complete. This is a classic reentrancy vulnerability. 
",1472,47,1.916689157485962
126,reentrancy,"YES
 
The contract uses a function `_transferWithRate` that allows for multiple calls to the same function. This creates a reentrancy vulnerability. 
",759,36,1.4531776905059814
127,time manipulation,"YES

The contract relies heavily on `block.timestamp` for its functionality, making it susceptible to manipulation by miners. This is a classic vulnerability, as miners can adjust the timestamp to their advantage. 
",661,43,1.7182600498199463
128,time manipulation,"YES
 
The contract relies heavily on the `block.timestamp` for its functionality, particularly in the `payOut` function and the `randomGen` function. This makes it susceptible to manipulation by miners, as they can alter the reported timestamp. 
",932,55,2.1902308464050293
129,time manipulation,"YES
 
The contract relies heavily on `block.timestamp` for its functionality, making it vulnerable to manipulation by miners.  The `lastInvestmentTimestamp` is directly tied to the block timestamp, making it susceptible to attacks where miners can alter the timestamp to manipulate the contract's behavior. 
",1144,63,2.520921468734741
130,time manipulation,"YES
 
The contract uses `now` to determine the current block timestamp. This is vulnerable to manipulation by miners. 
",780,28,1.1502923965454102
131,time manipulation,"YES
 
The contract relies heavily on `block.timestamp` for its random number generation. This makes it vulnerable to manipulation by miners, as they can adjust the timestamp to influence the outcome of the lottery. 
",930,46,1.8615021705627441
132,short addresses,"YES
 
The code has a potential vulnerability related to the `_transferWithRate` function.  Here's why:

* **Unclear Transfer Rate and Fee Logic:** The function's logic for calculating transfer fees and transfer rates is not clearly defined. This makes it difficult to assess the security of the contract.
* **Potential for Arbitrary Fee Manipulation:** The code allows for arbitrary fees to be charged, which could be exploited by attackers. 
* **Lack of Robust Rate and Fee Management:** The code lacks robust rate and fee management, making it vulnerable to manipulation. 
* **Potential for Unintended Transfers:** The code's logic for transferring tokens and managing balances is not clear, making it vulnerable to unintended transfers. 


It's important to note that this is a complex issue and requires a deep understanding of the code and the underlying blockchain. 
",968,182,7.019053936004639
133,denial of service,"YES
 
The contract has a potential denial of service vulnerability.  The `emptyCreditors` function can be exploited to reset the contract's state and potentially cause it to become unresponsive. 
",933,43,1.7301995754241943
134,denial of service,"YES
 
The contract's `_transferWithRate` function is vulnerable to Denial of Service attacks.  The function has a complex logic that can be exploited to cause a denial of service. 
",1064,44,1.7943451404571533
135,denial of service,"YES
 
The code has a vulnerability related to the `_transferWithRate` function.  It allows for the attacker to manipulate the `_transferWithRate` function to drain funds from the contract. 
",2293,46,1.9553618431091309
136,denial of service,"YES
 
The contract has a potential denial of service vulnerability.  The `_transferWithRate` function is designed to transfer funds, but it includes a series of checks that could be exploited to cause a denial of service.  The checks are designed to ensure that the transfer is allowed, but they could be bypassed by an attacker. 
",953,72,2.837097644805908
137,denial of service,"YES
 
The contract's `_transferWithRate` function is vulnerable to a Denial of Service (DoS) attack.  The function includes a loop that pushes the sender's address into the `listAddresses` array. This can lead to a DoS attack if the attacker can control the loop and push a large number of addresses into the array. 
",792,77,3.0199639797210693
138,denial of service,"YES
 
The code implements a function `_transferWithRate` that appears to be designed to transfer funds, but it includes several vulnerabilities that could lead to denial of service attacks. 

Here's why:

* **Unclear Transfer Rate:** The code doesn't specify how the transfer rate is determined. This could be manipulated by an attacker to drain funds.
* **Unclear Transfer Fee:** The code doesn't specify how the transfer fee is calculated. This could be manipulated by an attacker to drain funds.
* **Unclear Access Control:** The code uses `allowed` array to control access to funds. This could be manipulated by an attacker to drain funds.
* **Unclear Balance Checks:** The code doesn't check for sufficient balances before transferring funds. This could be manipulated by an attacker to drain funds. 
* **Unclear Transfer Fee Calculation:** The code doesn't specify how the transfer fee is calculated. This could be manipulated by an attacker to drain funds. 
* **Unclear Fee Receivers:** The code doesn't specify how the fee receivers are determined. This could be manipulated by an attacker to drain funds. 


These vulnerabilities make the contract susceptible to denial of service attacks. 
",764,258,9.944350481033325
